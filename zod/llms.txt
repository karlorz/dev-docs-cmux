# Zod

Zod is a TypeScript-first schema validation library with static type inference. It allows you to define schemas that validate data at runtime while automatically inferring TypeScript types, eliminating the need to write types and runtime validation separately. Zod works in Node.js and all modern browsers, has zero external dependencies, and features a tiny 2kb core bundle (gzipped).

Zod 4 is the current stable release, offering significant performance improvements (up to 14x faster string parsing, 7x faster array parsing, 6.5x faster object parsing), 100x reduction in TypeScript compiler instantiations, and 2x smaller bundle size. It introduces native JSON Schema conversion, a tree-shakable Zod Mini variant for bundle-critical applications, and first-class metadata support via registries.

## Basic Schema Definition and Parsing

Define schemas to validate data structures and use parse methods to validate inputs with automatic type inference.

```typescript
import * as z from "zod";

// Define a schema
const User = z.object({
  name: z.string(),
  email: z.email(),
  age: z.number().min(0).max(120),
  isActive: z.boolean().default(true),
});

// Infer TypeScript type from schema
type User = z.infer<typeof User>;
// { name: string; email: string; age: number; isActive: boolean }

// Parse data - throws ZodError on failure
const user = User.parse({
  name: "Alice",
  email: "alice@example.com",
  age: 30,
});
// => { name: "Alice", email: "alice@example.com", age: 30, isActive: true }

// Safe parse - returns result object instead of throwing
const result = User.safeParse({ name: "Bob", email: "invalid", age: -5 });
if (!result.success) {
  console.log(result.error.issues);
  // [
  //   { code: "invalid_format", format: "email", path: ["email"], message: "Invalid email" },
  //   { code: "too_small", minimum: 0, path: ["age"], message: "Number must be >= 0" }
  // ]
} else {
  console.log(result.data); // Typed as User
}
```

## Primitive Types and Coercion

Validate and coerce primitive types including strings, numbers, booleans, and bigints.

```typescript
import * as z from "zod";

// Primitive schemas
const stringSchema = z.string();
const numberSchema = z.number();
const booleanSchema = z.boolean();
const bigintSchema = z.bigint();

// Coercion - automatically convert input to target type
const coercedNumber = z.coerce.number();
coercedNumber.parse("42");     // => 42
coercedNumber.parse(true);     // => 1

const coercedString = z.coerce.string();
coercedString.parse(123);      // => "123"
coercedString.parse(null);     // => "null"

const coercedBoolean = z.coerce.boolean();
coercedBoolean.parse("true");  // => true (truthy)
coercedBoolean.parse(0);       // => false (falsy)

// Stringbool for env-style boolean parsing
const envBool = z.stringbool();
envBool.parse("true");     // => true
envBool.parse("yes");      // => true
envBool.parse("1");        // => true
envBool.parse("false");    // => false
envBool.parse("no");       // => false
envBool.parse("0");        // => false
```

## String Validations and Formats

Validate strings with length constraints, patterns, and built-in formats like email, URL, UUID, and ISO dates.

```typescript
import * as z from "zod";

// String validations
const username = z.string()
  .min(3, "Username must be at least 3 characters")
  .max(20, "Username must be at most 20 characters")
  .regex(/^[a-z0-9_]+$/, "Username can only contain lowercase letters, numbers, and underscores");

username.parse("alice_123");  // => "alice_123"

// String transforms
const normalizedString = z.string().trim().toLowerCase();
normalizedString.parse("  HELLO  ");  // => "hello"

// Built-in string formats
const email = z.email();
const url = z.url();
const uuid = z.uuid();
const uuidV4 = z.uuidv4();
const ipv4 = z.ipv4();
const ipv6 = z.ipv6();
const jwt = z.jwt();
const base64 = z.base64();

// ISO date/time formats
const isoDate = z.iso.date();
isoDate.parse("2024-01-15");  // => "2024-01-15"

const isoDatetime = z.iso.datetime();
isoDatetime.parse("2024-01-15T10:30:00Z");  // => "2024-01-15T10:30:00Z"

const isoDatetimeWithOffset = z.iso.datetime({ offset: true });
isoDatetimeWithOffset.parse("2024-01-15T10:30:00+02:00");  // => valid

const isoTime = z.iso.time();
isoTime.parse("10:30:00");  // => "10:30:00"

// Custom email regex options
const gmailStyle = z.email();  // Default strict regex
const html5Email = z.email({ pattern: z.regexes.html5Email });
const unicodeEmail = z.email({ pattern: z.regexes.unicodeEmail });
```

## Number and Integer Validations

Validate numbers with range constraints, integer checks, and specialized numeric formats.

```typescript
import * as z from "zod";

// Number validations
const score = z.number()
  .min(0, "Score must be positive")
  .max(100, "Score cannot exceed 100");

score.parse(85);   // => 85
score.parse(150);  // throws ZodError

// Number constraints
const positiveNum = z.number().positive();
const negativeNum = z.number().negative();
const nonNegative = z.number().nonnegative();
const multipleOf5 = z.number().multipleOf(5);

// Integer validation
const safeInt = z.int();  // Safe integer range
safeInt.parse(42);        // => 42
safeInt.parse(3.14);      // throws ZodError

// Fixed-width numeric types
const int32 = z.int32();     // [-2147483648, 2147483647]
const uint32 = z.uint32();   // [0, 4294967295]
const float32 = z.float32();
const float64 = z.float64();

// BigInt validations
const bigintSchema = z.bigint().positive().multipleOf(10n);
bigintSchema.parse(100n);  // => 100n

// BigInt fixed-width types
const int64 = z.int64();
const uint64 = z.uint64();
```

## Object Schemas

Define object schemas with required, optional, and nested properties, plus schema manipulation methods.

```typescript
import * as z from "zod";

// Basic object schema
const Person = z.object({
  name: z.string(),
  age: z.number(),
  email: z.string().email().optional(),
});

type Person = z.infer<typeof Person>;
// { name: string; age: number; email?: string }

// Strict object - throws on unknown keys
const StrictPerson = z.strictObject({
  name: z.string(),
  age: z.number(),
});
StrictPerson.parse({ name: "Alice", age: 30, extra: true });  // throws ZodError

// Loose object - passes through unknown keys
const LoosePerson = z.looseObject({
  name: z.string(),
});
LoosePerson.parse({ name: "Alice", extra: true });  // => { name: "Alice", extra: true }

// Extend schemas
const Employee = Person.extend({
  employeeId: z.string(),
  department: z.string(),
});

// Pick and omit
const NameOnly = Person.pick({ name: true });
const PersonWithoutEmail = Person.omit({ email: true });

// Partial and required
const PartialPerson = Person.partial();  // All fields optional
const RequiredPerson = Person.required();  // All fields required
const PartialAge = Person.partial({ age: true });  // Only age is optional

// Access shape
Person.shape.name;  // ZodString
Person.shape.age;   // ZodNumber

// Get keys as enum
const PersonKeys = Person.keyof();  // ZodEnum<["name", "age", "email"]>
```

## Arrays and Tuples

Validate arrays with element types, length constraints, and fixed-length tuples.

```typescript
import * as z from "zod";

// Array schema
const stringArray = z.array(z.string());
stringArray.parse(["a", "b", "c"]);  // => ["a", "b", "c"]

// Array with constraints
const limitedArray = z.array(z.number())
  .min(1, "Array must have at least 1 element")
  .max(10, "Array cannot have more than 10 elements");

const exactArray = z.array(z.string()).length(3);

// Access element schema
stringArray.unwrap();  // => ZodString

// Tuple - fixed length with specific types per position
const coordinate = z.tuple([z.number(), z.number()]);
type Coordinate = z.infer<typeof coordinate>;  // [number, number]

coordinate.parse([10, 20]);  // => [10, 20]
coordinate.parse([10]);      // throws ZodError

// Tuple with rest element
const atLeastTwo = z.tuple([z.string(), z.string()], z.string());
type AtLeastTwo = z.infer<typeof atLeastTwo>;  // [string, string, ...string[]]

atLeastTwo.parse(["a", "b"]);        // => ["a", "b"]
atLeastTwo.parse(["a", "b", "c"]);   // => ["a", "b", "c"]
```

## Unions and Discriminated Unions

Create union types for values that can be one of several types, with optimized discriminated unions.

```typescript
import * as z from "zod";

// Basic union
const stringOrNumber = z.union([z.string(), z.number()]);
stringOrNumber.parse("hello");  // => "hello"
stringOrNumber.parse(42);       // => 42

// Discriminated union - more efficient for objects with shared discriminator
const Result = z.discriminatedUnion("status", [
  z.object({ status: z.literal("success"), data: z.string() }),
  z.object({ status: z.literal("error"), error: z.string() }),
]);

type Result = z.infer<typeof Result>;
// { status: "success"; data: string } | { status: "error"; error: string }

const success = Result.parse({ status: "success", data: "Hello" });
const error = Result.parse({ status: "error", error: "Something went wrong" });

// Nested discriminated unions
const ApiResponse = z.discriminatedUnion("type", [
  z.object({ type: z.literal("user"), user: z.object({ name: z.string() }) }),
  z.discriminatedUnion("errorType", [
    z.object({ type: z.literal("error"), errorType: z.literal("validation"), fields: z.array(z.string()) }),
    z.object({ type: z.literal("error"), errorType: z.literal("auth"), message: z.string() }),
  ]),
]);

// Exclusive union (XOR) - exactly one must match
const exclusiveUnion = z.xor([
  z.object({ type: z.literal("card"), cardNumber: z.string() }),
  z.object({ type: z.literal("bank"), accountNumber: z.string() }),
]);
```

## Enums and Literals

Define schemas for exact literal values and enumerated types.

```typescript
import * as z from "zod";

// Literal values
const tuna = z.literal("tuna");
tuna.parse("tuna");     // => "tuna"
tuna.parse("salmon");   // throws ZodError

// Multiple literals
const fishTypes = z.literal(["salmon", "tuna", "trout"]);
fishTypes.parse("salmon");  // => "salmon"

// String enum
const Status = z.enum(["pending", "active", "inactive"]);
type Status = z.infer<typeof Status>;  // "pending" | "active" | "inactive"

Status.parse("active");    // => "active"
Status.enum.active;        // => "active"

// Enum from TypeScript enum
enum Color {
  Red = "red",
  Green = "green",
  Blue = "blue",
}
const ColorSchema = z.enum(Color);
ColorSchema.parse(Color.Red);  // => "red"
ColorSchema.parse("red");      // => "red"

// Numeric enum
const Priority = {
  Low: 1,
  Medium: 2,
  High: 3,
} as const;
const PrioritySchema = z.enum(Priority);
PrioritySchema.parse(Priority.High);  // => 3
PrioritySchema.parse(2);               // => 2

// Extract/exclude enum values
const ActiveOrPending = Status.extract(["active", "pending"]);
const NotPending = Status.exclude(["pending"]);
```

## Optional, Nullable, and Default Values

Handle optional fields, nullable values, and default value assignment.

```typescript
import * as z from "zod";

// Optional - allows undefined
const optionalString = z.optional(z.string());
// or: z.string().optional()
optionalString.parse("hello");    // => "hello"
optionalString.parse(undefined);  // => undefined

// Nullable - allows null
const nullableString = z.nullable(z.string());
// or: z.string().nullable()
nullableString.parse("hello");  // => "hello"
nullableString.parse(null);     // => null

// Nullish - allows both null and undefined
const nullishString = z.nullish(z.string());
nullishString.parse(undefined);  // => undefined
nullishString.parse(null);       // => null

// Default values
const withDefault = z.string().default("default value");
withDefault.parse(undefined);  // => "default value"
withDefault.parse("hello");    // => "hello"

// Dynamic default
const randomId = z.string().default(() => crypto.randomUUID());

// Prefault - pre-parse default (value is still parsed)
const trimmedDefault = z.string().trim().prefault("  hello  ");
trimmedDefault.parse(undefined);  // => "hello" (trimmed)

// Catch - fallback on validation error
const safeNumber = z.number().catch(0);
safeNumber.parse(42);      // => 42
safeNumber.parse("bad");   // => 0 (fallback)
```

## Refinements and Custom Validation

Add custom validation logic with refinements and superRefine for complex validation scenarios.

```typescript
import * as z from "zod";

// Simple refinement
const positiveEvenNumber = z.number()
  .refine(n => n > 0, "Must be positive")
  .refine(n => n % 2 === 0, "Must be even");

positiveEvenNumber.parse(4);   // => 4
positiveEvenNumber.parse(-2);  // throws ZodError: "Must be positive"

// Refinement with custom error path (useful for objects)
const passwordForm = z.object({
  password: z.string().min(8),
  confirmPassword: z.string(),
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

// Async refinement
const uniqueUsername = z.string().refine(
  async (username) => {
    const exists = await checkUsernameExists(username);
    return !exists;
  },
  "Username already taken"
);
// Must use parseAsync with async refinements
await uniqueUsername.parseAsync("alice");

// SuperRefine for multiple issues
const complexValidation = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 5) {
    ctx.addIssue({
      code: "too_big",
      maximum: 5,
      origin: "array",
      inclusive: true,
      message: "Too many items",
      input: val,
    });
  }
  if (new Set(val).size !== val.length) {
    ctx.addIssue({
      code: "custom",
      message: "No duplicates allowed",
      input: val,
    });
  }
});
```

## Transforms and Pipes

Transform data during parsing and chain schemas together with pipes.

```typescript
import * as z from "zod";

// Transform - change the output type
const stringToLength = z.string().transform(s => s.length);
type StringToLength = z.infer<typeof stringToLength>;  // number

stringToLength.parse("hello");  // => 5

// Transform with validation
const parseJson = z.string().transform((str, ctx) => {
  try {
    return JSON.parse(str);
  } catch {
    ctx.issues.push({
      code: "custom",
      message: "Invalid JSON",
      input: str,
    });
    return z.NEVER;
  }
});

// Pipe - chain schemas
const stringToNumber = z.string()
  .pipe(z.transform(s => parseInt(s, 10)))
  .pipe(z.number().min(0));

stringToNumber.parse("42");   // => 42
stringToNumber.parse("-5");   // throws (min 0)

// Preprocess - transform before validation
const trimmedString = z.preprocess(
  val => typeof val === "string" ? val.trim() : val,
  z.string()
);

// Input/output types can differ
const schema = z.string().transform(val => val.length);
type Input = z.input<typeof schema>;   // string
type Output = z.output<typeof schema>; // number
```

## Records and Maps

Validate dictionary-like objects and Map/Set collections.

```typescript
import * as z from "zod";

// Record with string keys
const StringRecord = z.record(z.string(), z.number());
type StringRecord = z.infer<typeof StringRecord>;  // Record<string, number>

StringRecord.parse({ a: 1, b: 2 });  // => { a: 1, b: 2 }

// Record with enum keys (exhaustive by default in Zod 4)
const StatusCounts = z.record(
  z.enum(["pending", "active", "done"]),
  z.number()
);
// Requires all enum keys to be present
StatusCounts.parse({ pending: 1, active: 2, done: 3 });

// Partial record - doesn't require all keys
const PartialStatusCounts = z.partialRecord(
  z.enum(["pending", "active", "done"]),
  z.number()
);
PartialStatusCounts.parse({ pending: 1 });  // valid

// Map schema
const userCache = z.map(z.string(), z.object({ name: z.string() }));
type UserCache = z.infer<typeof userCache>;  // Map<string, { name: string }>

const cache = new Map([["1", { name: "Alice" }]]);
userCache.parse(cache);

// Set schema
const uniqueIds = z.set(z.string()).min(1).max(100);
type UniqueIds = z.infer<typeof uniqueIds>;  // Set<string>

uniqueIds.parse(new Set(["a", "b"]));
```

## Recursive and Mutually Recursive Types

Define self-referencing schemas for tree structures and linked data.

```typescript
import * as z from "zod";

// Recursive type using getter
const Category = z.object({
  name: z.string(),
  get subcategories() {
    return z.array(Category);
  },
});

type Category = z.infer<typeof Category>;
// { name: string; subcategories: Category[] }

const tree: Category = {
  name: "Root",
  subcategories: [
    { name: "Child 1", subcategories: [] },
    { name: "Child 2", subcategories: [
      { name: "Grandchild", subcategories: [] }
    ]},
  ],
};
Category.parse(tree);

// Mutually recursive types
const User = z.object({
  name: z.string(),
  get posts() {
    return z.array(Post);
  },
});

const Post = z.object({
  title: z.string(),
  get author() {
    return User;
  },
});

// All object methods work with recursive schemas
const UserWithoutPosts = User.omit({ posts: true });
const PartialUser = User.partial();
```

## JSON Schema Conversion

Convert Zod schemas to and from JSON Schema format for API documentation and interoperability.

```typescript
import * as z from "zod";

// Convert Zod schema to JSON Schema
const Person = z.object({
  name: z.string(),
  age: z.number().int().min(0),
  email: z.email().optional(),
});

const jsonSchema = z.toJSONSchema(Person);
// {
//   type: "object",
//   properties: {
//     name: { type: "string" },
//     age: { type: "integer", minimum: 0 },
//     email: { type: "string", format: "email" }
//   },
//   required: ["name", "age"],
//   additionalProperties: false
// }

// With metadata
const UserWithMeta = z.object({
  id: z.string().meta({ title: "User ID", description: "Unique identifier" }),
  email: z.email().meta({ examples: ["user@example.com"] }),
});

z.toJSONSchema(UserWithMeta);
// Includes title, description, examples in output

// Conversion options
z.toJSONSchema(Person, {
  target: "openapi-3.0",      // Target format
  io: "input",               // Use input type instead of output
  unrepresentable: "any",    // Handle unrepresentable types as {}
  cycles: "ref",             // Handle cycles with $ref
});

// Convert JSON Schema to Zod (experimental)
const zodSchema = z.fromJSONSchema({
  type: "object",
  properties: {
    name: { type: "string" },
    age: { type: "number" },
  },
  required: ["name", "age"],
});
```

## Metadata and Registries

Attach metadata to schemas for documentation, form generation, and code generation.

```typescript
import * as z from "zod";

// Add metadata with .meta()
const UserSchema = z.object({
  name: z.string().meta({
    title: "Full Name",
    description: "User's full name",
    examples: ["John Doe"],
  }),
  email: z.email().meta({
    title: "Email Address",
    description: "Primary email for notifications",
  }),
});

// Retrieve metadata
UserSchema.shape.name.meta();
// { title: "Full Name", description: "User's full name", examples: ["John Doe"] }

// Create custom registry with typed metadata
const formRegistry = z.registry<{
  label: string;
  placeholder?: string;
  helpText?: string;
}>();

const FormField = z.string().register(formRegistry, {
  label: "Username",
  placeholder: "Enter username",
  helpText: "Must be unique",
});

formRegistry.get(FormField);
// { label: "Username", placeholder: "Enter username", helpText: "Must be unique" }

// Registry with type-aware metadata
type MetaWithExamples = { examples: z.$output[] };
const examplesRegistry = z.registry<MetaWithExamples>();

examplesRegistry.add(z.string(), { examples: ["hello", "world"] });
examplesRegistry.add(z.number(), { examples: [1, 2, 3] });
```

## Error Handling and Customization

Customize error messages globally, per-schema, or per-parse with support for internationalization.

```typescript
import * as z from "zod";
import { fr } from "zod/locales";

// Custom error messages per schema
const username = z.string({
  error: "Username must be a string",
}).min(3, {
  error: "Username must be at least 3 characters",
}).max(20, {
  error: "Username cannot exceed 20 characters",
});

// Dynamic error messages
const age = z.number({
  error: (issue) => {
    if (issue.input === undefined) return "Age is required";
    return "Age must be a number";
  },
}).min(0, {
  error: (issue) => `Age must be at least ${issue.minimum}`,
});

// Per-parse error customization
const result = z.string().safeParse(123, {
  error: (issue) => `Custom error: expected string, got ${typeof issue.input}`,
});

// Global error customization
z.config({
  customError: (issue) => {
    if (issue.code === "invalid_type") {
      return `Expected ${issue.expected}, received ${typeof issue.input}`;
    }
    return undefined; // Fall back to default
  },
});

// Internationalization
z.config(fr()); // Use French locale

// Pretty print errors
const error = new z.ZodError([
  { code: "invalid_type", expected: "string", path: ["name"], message: "Invalid" },
]);
console.log(z.prettifyError(error));
// ✖ Invalid
//   → at name
```

## File Validation

Validate File instances with size and MIME type constraints.

```typescript
import * as z from "zod";

// Basic file validation
const fileSchema = z.file();

// File with constraints
const imageFile = z.file()
  .min(1024, "File must be at least 1KB")
  .max(5 * 1024 * 1024, "File must be at most 5MB")
  .mime(["image/png", "image/jpeg", "image/gif"]);

// Validate file upload
const uploadSchema = z.object({
  avatar: imageFile.optional(),
  documents: z.array(z.file().max(10 * 1024 * 1024)).max(5),
});

// Example usage with FormData (in browser/Node.js)
const formData = new FormData();
// formData.append("avatar", file);

const files = {
  avatar: formData.get("avatar"),
  documents: formData.getAll("documents"),
};
uploadSchema.parse(files);
```

## Branded Types

Create nominal types for type-safe distinctions between structurally identical types.

```typescript
import * as z from "zod";

// Create branded types
const UserId = z.string().uuid().brand<"UserId">();
const PostId = z.string().uuid().brand<"PostId">();

type UserId = z.infer<typeof UserId>;  // string & z.$brand<"UserId">
type PostId = z.infer<typeof PostId>;  // string & z.$brand<"PostId">

// Parse to get branded value
const userId = UserId.parse("550e8400-e29b-41d4-a716-446655440000");
const postId = PostId.parse("550e8400-e29b-41d4-a716-446655440001");

// Type-safe usage
function getUser(id: UserId) { /* ... */ }
function getPost(id: PostId) { /* ... */ }

getUser(userId);  // OK
getUser(postId);  // Type error! PostId not assignable to UserId

// Brand direction options
const InputBranded = z.string().brand<"Token", "in">();   // Input branded
const OutputBranded = z.string().brand<"Token", "out">(); // Output branded (default)
const BothBranded = z.string().brand<"Token", "inout">(); // Both branded
```

## Zod Mini (Tree-shakable Variant)

Use Zod Mini for bundle-critical applications with a functional, tree-shakable API.

```typescript
import * as z from "zod/mini";

// Functional API instead of methods
const User = z.object({
  name: z.string(),
  age: z.optional(z.number()),
});

// Validations use .check() with functions
const password = z.string().check(
  z.minLength(8),
  z.maxLength(100),
  z.regex(/[A-Z]/, { error: "Must contain uppercase" }),
  z.regex(/[0-9]/, { error: "Must contain number" })
);

// Object manipulation uses functions
const UserWithEmail = z.extend(User, { email: z.email() });
const PartialUser = z.partial(User);
const PickedUser = z.pick(User, { name: true });

// Refinements
const evenNumber = z.number().check(
  z.refine(n => n % 2 === 0, { error: "Must be even" })
);

// Parsing
z.parse(User, { name: "Alice", age: 30 });
const result = z.safeParse(User, { name: "Alice" });

// Bundle size comparison:
// - Zod 3: 12.47kb (gzipped core)
// - Zod 4: 5.36kb (gzipped core)
// - Zod Mini: 1.88kb (gzipped core)
```

Zod is widely used in the TypeScript ecosystem for runtime validation with compile-time type safety. Common integration patterns include form validation with React Hook Form, API request/response validation in tRPC and Express/Fastify, environment variable validation, and structured output schemas for AI applications. The library's zero-dependency design and small bundle size make it suitable for both server and client applications.

The Zod ecosystem includes integrations with popular libraries: tRPC for end-to-end type-safe APIs, React Hook Form with @hookform/resolvers for form validation, drizzle-orm for database schema definitions, and @hono/zod-validator for Hono framework validation. JSON Schema conversion enables compatibility with OpenAPI documentation generators and AI structured output systems like OpenAI's function calling.
