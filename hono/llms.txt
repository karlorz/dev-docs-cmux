# Hono - Ultrafast Web Framework

Hono (meaning "flame" in Japanese) is a small, simple, and ultrafast web framework built on Web Standards. It works on any JavaScript runtime including Cloudflare Workers, Fastly Compute, Deno, Bun, Vercel, Netlify, AWS Lambda, Lambda@Edge, and Node.js. The framework weighs under 14kB with the `hono/tiny` preset, has zero dependencies, and uses only Web Standards APIs.

Hono provides a delightful developer experience with first-class TypeScript support, clean APIs, batteries-included middleware, and RPC capabilities for type-safe client-server communication. It's designed for building Web APIs, proxies, edge applications, CDN front-ends, and full-stack applications with performance that outpaces other JavaScript routers.

## Quick Start

Create a new Hono project using the CLI starter.

```bash
npm create hono@latest my-app
cd my-app
npm install
npm run dev
```

## Basic App Setup

Create and export a Hono application instance with route handlers.

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => c.text('Hello Hono!'))

app.get('/api/hello', (c) => {
  return c.json({
    ok: true,
    message: 'Hello Hono!',
  })
})

app.post('/posts', (c) => c.text('Created!', 201))

app.delete('/posts/:id', (c) =>
  c.text(`${c.req.param('id')} is deleted!`)
)

export default app
```

## HTTP Method Routing

Register handlers for different HTTP methods with path patterns including wildcards and custom methods.

```ts
import { Hono } from 'hono'

const app = new Hono()

// Standard HTTP methods
app.get('/', (c) => c.text('GET /'))
app.post('/', (c) => c.text('POST /'))
app.put('/', (c) => c.text('PUT /'))
app.delete('/', (c) => c.text('DELETE /'))

// Wildcard matching
app.get('/wild/*/card', (c) => c.text('GET /wild/*/card'))

// Any HTTP method
app.all('/hello', (c) => c.text('Any Method /hello'))

// Custom HTTP method
app.on('PURGE', '/cache', (c) => c.text('PURGE Method /cache'))

// Multiple methods on same path
app.on(['PUT', 'DELETE'], '/post', (c) => c.text('PUT or DELETE /post'))

// Multiple paths for same handler
app.on('GET', ['/hello', '/ja/hello', '/en/hello'], (c) => c.text('Hello'))

export default app
```

## Path Parameters

Extract dynamic path segments using named parameters with optional regex constraints.

```ts
import { Hono } from 'hono'

const app = new Hono()

// Basic path parameter
app.get('/user/:name', (c) => {
  const name = c.req.param('name')
  return c.text(`Hello, ${name}!`)
})

// Multiple parameters
app.get('/posts/:id/comment/:commentId', (c) => {
  const { id, commentId } = c.req.param()
  return c.json({ postId: id, commentId })
})

// Optional parameter
app.get('/api/animal/:type?', (c) => {
  const type = c.req.param('type') || 'all'
  return c.text(`Animal type: ${type}`)
})

// Regex constrained parameters
app.get('/post/:date{[0-9]+}/:title{[a-z]+}', (c) => {
  const { date, title } = c.req.param()
  return c.json({ date, title })
})

// Parameter including slashes
app.get('/posts/:filename{.+\\.png}', (c) => {
  const filename = c.req.param('filename')
  return c.text(`File: ${filename}`)
})

export default app
```

## Route Grouping

Organize routes into separate modules and mount them at specific base paths.

```ts
import { Hono } from 'hono'

// Create sub-router for books
const books = new Hono()
books.get('/', (c) => c.json({ books: ['Book 1', 'Book 2'] }))
books.get('/:id', (c) => c.json({ id: c.req.param('id'), title: 'Sample Book' }))
books.post('/', (c) => c.json({ message: 'Book created' }, 201))

// Create sub-router for authors with base path
const authors = new Hono().basePath('/authors')
authors.get('/', (c) => c.json({ authors: ['Author 1', 'Author 2'] }))
authors.get('/:id', (c) => c.json({ id: c.req.param('id'), name: 'Sample Author' }))

// Main application
const app = new Hono()
app.route('/books', books)   // /books, /books/:id
app.route('/', authors)      // /authors, /authors/:id

// API versioning with base path
const api = new Hono().basePath('/api/v1')
api.get('/users', (c) => c.json({ users: [] }))

export default app
```

## Context Response Methods

Use context methods to return different response types with headers and status codes.

```ts
import { Hono } from 'hono'

const app = new Hono()

// Text response
app.get('/text', (c) => c.text('Hello!'))

// JSON response
app.get('/json', (c) => c.json({ message: 'Hello!' }))

// HTML response
app.get('/html', (c) => c.html('<h1>Hello Hono!</h1>'))

// Set status code
app.post('/posts', (c) => {
  c.status(201)
  return c.text('Created!')
})

// Set custom headers
app.get('/headers', (c) => {
  c.header('X-Message', 'Custom header')
  c.header('X-Request-Id', crypto.randomUUID())
  return c.text('Check the headers!')
})

// Full response with status and headers
app.get('/full', (c) => {
  return c.body('Thank you', 201, {
    'X-Message': 'Hello!',
    'Content-Type': 'text/plain',
  })
})

// Redirect
app.get('/old-page', (c) => c.redirect('/new-page'))
app.get('/permanent', (c) => c.redirect('/new-location', 301))

// Not found
app.get('/maybe/:id', (c) => {
  const id = c.req.param('id')
  if (id === 'missing') {
    return c.notFound()
  }
  return c.json({ id })
})

export default app
```

## Request Data Access

Access query parameters, headers, and request body data through the HonoRequest object.

```ts
import { Hono } from 'hono'

const app = new Hono()

// Query parameters
app.get('/search', (c) => {
  const query = c.req.query('q')
  const limit = c.req.query('limit') || '10'
  const { page, sort } = c.req.query()
  return c.json({ query, limit, page, sort })
})

// Multiple values for same query param
app.get('/filter', (c) => {
  const tags = c.req.queries('tags') // string[]
  return c.json({ tags })
})

// Request headers
app.get('/info', (c) => {
  const userAgent = c.req.header('User-Agent')
  const auth = c.req.header('Authorization')
  return c.json({ userAgent, auth })
})

// JSON body
app.post('/api/users', async (c) => {
  const body = await c.req.json()
  return c.json({ received: body })
})

// Form data
app.post('/form', async (c) => {
  const body = await c.req.parseBody()
  return c.json({ name: body.name, email: body.email })
})

// File upload
app.post('/upload', async (c) => {
  const body = await c.req.parseBody()
  const file = body.file as File
  return c.json({
    filename: file.name,
    size: file.size,
    type: file.type
  })
})

// Request metadata
app.get('/meta', (c) => {
  return c.json({
    path: c.req.path,
    url: c.req.url,
    method: c.req.method
  })
})

export default app
```

## Middleware Basics

Apply middleware globally or to specific routes for cross-cutting concerns.

```ts
import { Hono } from 'hono'
import { logger } from 'hono/logger'
import { cors } from 'hono/cors'
import { basicAuth } from 'hono/basic-auth'

const app = new Hono()

// Global middleware
app.use(logger())
app.use(cors())

// Path-specific middleware
app.use('/api/*', cors({
  origin: 'http://example.com',
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowHeaders: ['Content-Type', 'Authorization'],
  maxAge: 600,
  credentials: true,
}))

// Auth on specific routes
app.use('/admin/*', basicAuth({
  username: 'admin',
  password: 'secret',
}))

// Custom inline middleware
app.use(async (c, next) => {
  const start = Date.now()
  await next()
  const ms = Date.now() - start
  c.header('X-Response-Time', `${ms}ms`)
})

// Route handlers
app.get('/', (c) => c.text('Public'))
app.get('/api/data', (c) => c.json({ data: 'API response' }))
app.get('/admin/dashboard', (c) => c.text('Admin Dashboard'))

export default app
```

## Custom Middleware Creation

Create reusable middleware with typed context variables using createMiddleware.

```ts
import { Hono } from 'hono'
import { createMiddleware } from 'hono/factory'

// Timing middleware
const timing = createMiddleware(async (c, next) => {
  const start = Date.now()
  await next()
  const duration = Date.now() - start
  c.header('X-Response-Time', `${duration}ms`)
})

// Auth middleware with typed variables
type AuthEnv = {
  Variables: {
    user: { id: string; name: string; role: string }
  }
}

const authMiddleware = createMiddleware<AuthEnv>(async (c, next) => {
  const token = c.req.header('Authorization')?.replace('Bearer ', '')

  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401)
  }

  // Simulate user lookup
  c.set('user', { id: '123', name: 'John', role: 'admin' })
  await next()
})

const app = new Hono<AuthEnv>()

app.use(timing)

app.get('/public', (c) => c.text('Public route'))

app.use('/protected/*', authMiddleware)

app.get('/protected/profile', (c) => {
  const user = c.get('user')
  return c.json({ user })
})

app.get('/protected/admin', (c) => {
  const user = c.get('user')
  if (user.role !== 'admin') {
    return c.json({ error: 'Forbidden' }, 403)
  }
  return c.json({ message: 'Admin access granted' })
})

export default app
```

## JWT Authentication

Protect routes with JWT token verification and access token payload data.

```ts
import { Hono } from 'hono'
import { jwt } from 'hono/jwt'
import type { JwtVariables } from 'hono/jwt'

type Variables = JwtVariables

const app = new Hono<{ Variables: Variables }>()

// Public routes
app.get('/', (c) => c.text('Public'))

// Protected routes with JWT
app.use('/api/*', jwt({
  secret: 'your-secret-key',
  alg: 'HS256',
}))

// Access JWT payload
app.get('/api/profile', (c) => {
  const payload = c.get('jwtPayload')
  return c.json({
    userId: payload.sub,
    email: payload.email,
    exp: payload.exp
  })
})

// JWT with environment variable secret
app.use('/secure/*', (c, next) => {
  const jwtMiddleware = jwt({
    secret: c.env.JWT_SECRET,
    alg: 'HS256',
  })
  return jwtMiddleware(c, next)
})

// JWT from cookie instead of header
app.use('/cookie-auth/*', jwt({
  secret: 'your-secret-key',
  alg: 'HS256',
  cookie: 'auth_token',
}))

export default app
```

## CORS Configuration

Configure Cross-Origin Resource Sharing for API endpoints with flexible origin handling.

```ts
import { Hono } from 'hono'
import { cors } from 'hono/cors'

const app = new Hono()

// Basic CORS - allow all origins
app.use('/api/*', cors())

// Specific origin
app.use('/api/v1/*', cors({
  origin: 'https://example.com',
  allowHeaders: ['Content-Type', 'Authorization'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  exposeHeaders: ['Content-Length'],
  maxAge: 600,
  credentials: true,
}))

// Multiple origins
app.use('/api/v2/*', cors({
  origin: ['https://app.example.com', 'https://admin.example.com'],
}))

// Dynamic origin validation
app.use('/api/v3/*', cors({
  origin: (origin, c) => {
    if (origin.endsWith('.example.com')) {
      return origin
    }
    return 'https://example.com'
  },
}))

// Environment-based CORS
app.use('/api/v4/*', async (c, next) => {
  const corsHandler = cors({
    origin: c.env.CORS_ORIGIN,
  })
  return corsHandler(c, next)
})

app.get('/api/data', (c) => c.json({ message: 'Hello' }))

export default app
```

## Validation with Zod

Validate request data using the built-in validator or Zod middleware for type-safe handlers.

```ts
import { Hono } from 'hono'
import { validator } from 'hono/validator'
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'

const app = new Hono()

// Manual validation
app.post('/posts',
  validator('form', (value, c) => {
    const title = value['title']
    if (!title || typeof title !== 'string') {
      return c.json({ error: 'Title is required' }, 400)
    }
    return { title }
  }),
  (c) => {
    const { title } = c.req.valid('form')
    return c.json({ message: `Post created: ${title}` }, 201)
  }
)

// Zod validation for JSON body
const createUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  age: z.number().min(0).optional(),
})

app.post('/users',
  zValidator('json', createUserSchema),
  (c) => {
    const data = c.req.valid('json')
    return c.json({ user: data }, 201)
  }
)

// Zod validation for query params
const searchSchema = z.object({
  q: z.string(),
  page: z.coerce.number().default(1),
  limit: z.coerce.number().max(100).default(10),
})

app.get('/search',
  zValidator('query', searchSchema),
  (c) => {
    const { q, page, limit } = c.req.valid('query')
    return c.json({ query: q, page, limit })
  }
)

// Multiple validators
app.put('/users/:id',
  zValidator('param', z.object({ id: z.string().uuid() })),
  zValidator('json', z.object({ name: z.string() })),
  (c) => {
    const { id } = c.req.valid('param')
    const { name } = c.req.valid('json')
    return c.json({ id, name, updated: true })
  }
)

export default app
```

## RPC Client

Share API type definitions between server and client for end-to-end type safety.

```ts
// server.ts
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'

const app = new Hono()

const route = app
  .get('/posts', (c) => {
    return c.json([
      { id: 1, title: 'Hello' },
      { id: 2, title: 'World' },
    ])
  })
  .get('/posts/:id', (c) => {
    const id = c.req.param('id')
    return c.json({ id, title: 'Sample Post' })
  })
  .post('/posts',
    zValidator('json', z.object({
      title: z.string(),
      body: z.string(),
    })),
    (c) => {
      const data = c.req.valid('json')
      return c.json({ id: 3, ...data }, 201)
    }
  )

export type AppType = typeof route
export default app

// client.ts
import { hc } from 'hono/client'
import type { AppType } from './server'

const client = hc<AppType>('http://localhost:8787')

// Type-safe API calls
async function main() {
  // GET request
  const postsRes = await client.posts.$get()
  const posts = await postsRes.json()
  console.log(posts) // [{ id: 1, title: 'Hello' }, ...]

  // GET with path param
  const postRes = await client.posts[':id'].$get({
    param: { id: '1' }
  })
  const post = await postRes.json()
  console.log(post) // { id: '1', title: 'Sample Post' }

  // POST request
  const createRes = await client.posts.$post({
    json: { title: 'New Post', body: 'Content here' }
  })
  const created = await createRes.json()
  console.log(created) // { id: 3, title: 'New Post', body: 'Content here' }
}
```

## Cookie Management

Set, get, and delete cookies including signed cookies for secure data storage.

```ts
import { Hono } from 'hono'
import {
  getCookie,
  setCookie,
  deleteCookie,
  getSignedCookie,
  setSignedCookie
} from 'hono/cookie'

const app = new Hono()

// Basic cookie operations
app.get('/set-cookie', (c) => {
  setCookie(c, 'user_preference', 'dark_mode', {
    path: '/',
    secure: true,
    httpOnly: true,
    maxAge: 60 * 60 * 24 * 7, // 1 week
    sameSite: 'Strict',
  })
  return c.text('Cookie set!')
})

app.get('/get-cookie', (c) => {
  const preference = getCookie(c, 'user_preference')
  const allCookies = getCookie(c)
  return c.json({ preference, allCookies })
})

app.get('/delete-cookie', (c) => {
  const deleted = deleteCookie(c, 'user_preference')
  return c.json({ deleted })
})

// Signed cookies for tamper-proof data
const SECRET = 'my-secret-key-at-least-32-chars-long'

app.get('/set-signed', async (c) => {
  await setSignedCookie(c, 'session_id', 'abc123', SECRET, {
    path: '/',
    httpOnly: true,
  })
  return c.text('Signed cookie set!')
})

app.get('/get-signed', async (c) => {
  const sessionId = await getSignedCookie(c, SECRET, 'session_id')
  if (sessionId === false) {
    return c.json({ error: 'Invalid or tampered cookie' }, 400)
  }
  return c.json({ sessionId })
})

export default app
```

## Error Handling

Handle errors gracefully with HTTPException and custom error handlers.

```ts
import { Hono } from 'hono'
import { HTTPException } from 'hono/http-exception'

const app = new Hono()

// Throw HTTPException with message
app.get('/protected', (c) => {
  const auth = c.req.header('Authorization')
  if (!auth) {
    throw new HTTPException(401, { message: 'Unauthorized' })
  }
  return c.text('Protected content')
})

// HTTPException with custom response
app.get('/api/resource/:id', async (c) => {
  const id = c.req.param('id')
  const resource = await findResource(id)

  if (!resource) {
    throw new HTTPException(404, {
      res: new Response(JSON.stringify({ error: 'Resource not found', id }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
      }),
    })
  }
  return c.json(resource)
})

// Custom 404 handler
app.notFound((c) => {
  return c.json({ error: 'Not Found', path: c.req.path }, 404)
})

// Global error handler
app.onError((err, c) => {
  console.error(`${err}`)

  if (err instanceof HTTPException) {
    return err.getResponse()
  }

  return c.json({
    error: 'Internal Server Error',
    message: err.message
  }, 500)
})

async function findResource(id: string) {
  return id === '1' ? { id, name: 'Resource' } : null
}

export default app
```

## Streaming Responses

Stream data to clients using text streams and Server-Sent Events (SSE).

```ts
import { Hono } from 'hono'
import { stream, streamText, streamSSE } from 'hono/streaming'

const app = new Hono()

// Basic streaming
app.get('/stream', (c) => {
  return stream(c, async (stream) => {
    stream.onAbort(() => console.log('Stream aborted'))

    await stream.write(new Uint8Array([72, 101, 108, 108, 111]))
    await stream.write(new Uint8Array([32, 87, 111, 114, 108, 100]))
  })
})

// Text streaming
app.get('/stream-text', (c) => {
  return streamText(c, async (stream) => {
    await stream.writeln('Starting process...')
    await stream.sleep(1000)
    await stream.writeln('Processing step 1...')
    await stream.sleep(1000)
    await stream.writeln('Processing step 2...')
    await stream.sleep(1000)
    await stream.write('Done!')
  })
})

// Server-Sent Events
let eventId = 0

app.get('/sse', (c) => {
  return streamSSE(c, async (stream) => {
    while (true) {
      const data = {
        time: new Date().toISOString(),
        value: Math.random(),
      }

      await stream.writeSSE({
        data: JSON.stringify(data),
        event: 'update',
        id: String(eventId++),
      })

      await stream.sleep(1000)
    }
  })
})

// Streaming with error handling
app.get('/stream-safe', (c) => {
  return stream(
    c,
    async (stream) => {
      await stream.write(new Uint8Array([72, 105]))
      throw new Error('Something went wrong')
    },
    (err, stream) => {
      stream.writeln(`Error: ${err.message}`)
    }
  )
})

export default app
```

## JSX Templates

Render HTML using JSX syntax for server-side rendering with component composition.

```tsx
import { Hono } from 'hono'
import type { FC } from 'hono/jsx'

const app = new Hono()

// Layout component
const Layout: FC<{ title: string }> = (props) => {
  return (
    <html>
      <head>
        <title>{props.title}</title>
        <meta charset="UTF-8" />
      </head>
      <body>{props.children}</body>
    </html>
  )
}

// Page component
const HomePage: FC<{ user: string }> = ({ user }) => {
  return (
    <Layout title="Home">
      <h1>Welcome, {user}!</h1>
      <nav>
        <a href="/about">About</a>
        <a href="/contact">Contact</a>
      </nav>
    </Layout>
  )
}

// List component
const PostList: FC<{ posts: Array<{ id: number; title: string }> }> = ({ posts }) => {
  return (
    <Layout title="Posts">
      <h1>All Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <a href={`/posts/${post.id}`}>{post.title}</a>
          </li>
        ))}
      </ul>
    </Layout>
  )
}

// Routes
app.get('/', (c) => {
  return c.html(<HomePage user="Guest" />)
})

app.get('/posts', (c) => {
  const posts = [
    { id: 1, title: 'Getting Started' },
    { id: 2, title: 'Advanced Topics' },
  ]
  return c.html(<PostList posts={posts} />)
})

// Async component
const AsyncData: FC = async () => {
  await new Promise((r) => setTimeout(r, 100))
  return <div>Data loaded!</div>
}

app.get('/async', (c) => {
  return c.html(
    <Layout title="Async">
      <AsyncData />
    </Layout>
  )
})

export default app
```

## Testing

Test Hono applications using the built-in request method with various HTTP scenarios.

```ts
import { Hono } from 'hono'
import { describe, it, expect } from 'vitest'

const app = new Hono()

app.get('/posts', (c) => c.text('Many posts'))

app.post('/posts', async (c) => {
  const body = await c.req.json()
  return c.json({ message: 'Created', data: body }, 201, {
    'X-Custom': 'Thank you',
  })
})

app.get('/protected', (c) => {
  const auth = c.req.header('Authorization')
  if (!auth) return c.text('Unauthorized', 401)
  return c.text('Protected content')
})

// Tests
describe('API Tests', () => {
  it('GET /posts returns 200', async () => {
    const res = await app.request('/posts')
    expect(res.status).toBe(200)
    expect(await res.text()).toBe('Many posts')
  })

  it('POST /posts creates resource', async () => {
    const res = await app.request('/posts', {
      method: 'POST',
      body: JSON.stringify({ title: 'New Post' }),
      headers: { 'Content-Type': 'application/json' },
    })
    expect(res.status).toBe(201)
    expect(res.headers.get('X-Custom')).toBe('Thank you')
    expect(await res.json()).toEqual({
      message: 'Created',
      data: { title: 'New Post' },
    })
  })

  it('POST /posts with FormData', async () => {
    const formData = new FormData()
    formData.append('title', 'Form Post')
    const res = await app.request('/posts', {
      method: 'POST',
      body: formData,
    })
    expect(res.status).toBe(201)
  })

  it('Protected route requires auth', async () => {
    const res = await app.request('/protected')
    expect(res.status).toBe(401)
  })

  it('Protected route with auth succeeds', async () => {
    const res = await app.request('/protected', {
      headers: { Authorization: 'Bearer token123' },
    })
    expect(res.status).toBe(200)
  })
})

// Testing with mock environment
describe('Environment Tests', () => {
  const appWithEnv = new Hono<{ Bindings: { API_KEY: string } }>()

  appWithEnv.get('/config', (c) => {
    return c.json({ apiKey: c.env.API_KEY })
  })

  it('uses mocked env', async () => {
    const res = await appWithEnv.request('/config', {}, { API_KEY: 'test-key' })
    expect(await res.json()).toEqual({ apiKey: 'test-key' })
  })
})
```

## Cloudflare Workers Bindings

Access Cloudflare Workers environment variables, KV namespaces, and D1 databases.

```ts
import { Hono } from 'hono'

type Bindings = {
  API_KEY: string
  MY_KV: KVNamespace
  DB: D1Database
}

const app = new Hono<{ Bindings: Bindings }>()

// Access environment variables
app.get('/config', (c) => {
  const apiKey = c.env.API_KEY
  return c.json({ configured: !!apiKey })
})

// KV namespace operations
app.get('/kv/:key', async (c) => {
  const key = c.req.param('key')
  const value = await c.env.MY_KV.get(key)
  if (!value) return c.notFound()
  return c.json({ key, value })
})

app.put('/kv/:key', async (c) => {
  const key = c.req.param('key')
  const { value } = await c.req.json()
  await c.env.MY_KV.put(key, value)
  return c.json({ success: true })
})

// D1 database operations
app.get('/users', async (c) => {
  const { results } = await c.env.DB
    .prepare('SELECT * FROM users')
    .all()
  return c.json({ users: results })
})

app.post('/users', async (c) => {
  const { name, email } = await c.req.json()
  const result = await c.env.DB
    .prepare('INSERT INTO users (name, email) VALUES (?, ?)')
    .bind(name, email)
    .run()
  return c.json({ id: result.lastRowId }, 201)
})

// Use waitUntil for background tasks
app.post('/log', async (c) => {
  const data = await c.req.json()

  c.executionCtx.waitUntil(
    c.env.MY_KV.put(`log:${Date.now()}`, JSON.stringify(data))
  )

  return c.json({ logged: true })
})

export default app
```

## Summary

Hono excels at building performant web APIs and edge applications with its lightweight core, extensive middleware ecosystem, and first-class TypeScript support. Common use cases include REST APIs on Cloudflare Workers, Deno, and Bun; backend services for frontend applications; serverless functions on AWS Lambda and Vercel; and full-stack applications with JSX templating. The RPC feature enables seamless type-safe communication between server and client code.

The framework integrates naturally with the JavaScript ecosystem through its adherence to Web Standards, allowing the same code to run across multiple runtimes without modification. Whether building microservices, API gateways, or complete web applications, Hono provides the tools needed while maintaining minimal overhead and maximum developer productivity through its clean, intuitive API design.
