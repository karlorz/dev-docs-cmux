# TanStack Query

TanStack Query (formerly React Query) is a powerful asynchronous state management library designed to simplify fetching, caching, synchronizing, and updating server state in web applications. It provides a declarative approach to data fetching that automatically handles caching, background updates, stale data management, and request deduplication. The library is protocol-agnostic, supporting REST APIs, GraphQL, and any Promise-based data sources, while offering framework adapters for React, Vue, Solid, Svelte, and Angular.

The core functionality centers around queries for reading data and mutations for creating, updating, or deleting data. TanStack Query intelligently manages cache invalidation, automatic refetching on window focus or network reconnection, pagination, infinite scrolling, and optimistic updates. It dramatically reduces boilerplate code typically needed for managing loading states, error handling, and data synchronization, enabling developers to build faster, more responsive applications with minimal effort.

## QueryClientProvider - Application Setup

The QueryClientProvider component connects a QueryClient instance to your React application, making it available throughout the component tree via React Context. This is required at the root level of any application using TanStack Query.

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

// Create a client with default options
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 30, // 30 minutes (garbage collection time)
      retry: 3,
      refetchOnWindowFocus: true,
    },
    mutations: {
      retry: 1,
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MyApplication />
    </QueryClientProvider>
  )
}
```

## useQuery - Data Fetching

The useQuery hook is the primary method for fetching and caching data. It requires a unique query key for cache identification and a query function that returns a Promise. The hook automatically manages loading states, errors, caching, background refetching, and deduplication of concurrent requests.

```tsx
import { useQuery } from '@tanstack/react-query'

interface Todo {
  id: number
  title: string
  completed: boolean
}

function TodoList() {
  const {
    data,
    isPending,
    isError,
    error,
    isFetching,
    refetch,
  } = useQuery<Todo[]>({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('https://api.example.com/todos')
      if (!response.ok) {
        throw new Error('Network response was not ok')
      }
      return response.json()
    },
    staleTime: 1000 * 60, // Data considered fresh for 1 minute
    refetchInterval: 1000 * 30, // Auto-refetch every 30 seconds
  })

  if (isPending) return <div>Loading...</div>
  if (isError) return <div>Error: {error.message}</div>

  return (
    <div>
      {isFetching && <span>Updating...</span>}
      <ul>
        {data.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  )
}
```

## useQuery with Parameters - Dynamic Query Keys

Query keys can include variables to create unique cache entries for different data sets. When the key changes, TanStack Query automatically fetches new data while keeping the previous data cached.

```tsx
import { useQuery } from '@tanstack/react-query'

interface User {
  id: number
  name: string
  email: string
}

function UserProfile({ userId }: { userId: number }) {
  const { data, isPending, error } = useQuery<User>({
    queryKey: ['user', userId], // Cache is unique per userId
    queryFn: async () => {
      const response = await fetch(`https://api.example.com/users/${userId}`)
      if (!response.ok) throw new Error('Failed to fetch user')
      return response.json()
    },
    enabled: userId > 0, // Only fetch when userId is valid
  })

  if (isPending) return <div>Loading user...</div>
  if (error) return <div>Error loading user</div>

  return (
    <div>
      <h2>{data?.name}</h2>
      <p>{data?.email}</p>
    </div>
  )
}
```

## useMutation - Data Modification

The useMutation hook handles creating, updating, or deleting data. It provides callbacks for handling success, error, and settlement states, and integrates seamlessly with query invalidation to keep the UI synchronized.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'

interface NewTodo {
  title: string
  completed: boolean
}

function AddTodo() {
  const queryClient = useQueryClient()

  const mutation = useMutation({
    mutationFn: async (newTodo: NewTodo) => {
      const response = await fetch('https://api.example.com/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTodo),
      })
      if (!response.ok) throw new Error('Failed to create todo')
      return response.json()
    },
    onSuccess: () => {
      // Invalidate and refetch todos after successful mutation
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
    onError: (error) => {
      console.error('Mutation failed:', error)
    },
  })

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    mutation.mutate({
      title: formData.get('title') as string,
      completed: false,
    })
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" placeholder="New todo" required />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Adding...' : 'Add Todo'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Todo added successfully!</div>}
    </form>
  )
}
```

## Optimistic Updates - Instant UI Feedback

Optimistic updates provide immediate UI feedback before the server confirms the mutation, with automatic rollback on failure. This creates a more responsive user experience.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'

interface Todo {
  id: number
  title: string
  completed: boolean
}

function TodoItem({ todo }: { todo: Todo }) {
  const queryClient = useQueryClient()

  const toggleMutation = useMutation({
    mutationFn: async (updatedTodo: Todo) => {
      const response = await fetch(`/api/todos/${updatedTodo.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedTodo),
      })
      return response.json()
    },
    onMutate: async (newTodo, context) => {
      // Cancel outgoing refetches
      await context.client.cancelQueries({ queryKey: ['todos'] })

      // Snapshot previous value
      const previousTodos = context.client.getQueryData<Todo[]>(['todos'])

      // Optimistically update cache
      context.client.setQueryData<Todo[]>(['todos'], (old) =>
        old?.map((t) => (t.id === newTodo.id ? newTodo : t))
      )

      // Return snapshot for rollback
      return { previousTodos }
    },
    onError: (err, newTodo, onMutateResult, context) => {
      // Rollback on error
      context.client.setQueryData(['todos'], onMutateResult?.previousTodos)
    },
    onSettled: (data, error, variables, onMutateResult, context) => {
      // Always refetch after mutation settles
      context.client.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <label>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() =>
          toggleMutation.mutate({ ...todo, completed: !todo.completed })
        }
      />
      {todo.title}
    </label>
  )
}
```

## useInfiniteQuery - Pagination and Infinite Scroll

The useInfiniteQuery hook manages paginated or infinite-scroll data by tracking pages and providing methods to load more content.

```tsx
import { useInfiniteQuery } from '@tanstack/react-query'
import { useRef, useCallback } from 'react'

interface ProjectsPage {
  data: Array<{ id: number; name: string }>
  nextCursor: number | null
}

function ProjectList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery<ProjectsPage>({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      const response = await fetch(`/api/projects?cursor=${pageParam}`)
      return response.json()
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  })

  // Intersection Observer for infinite scroll
  const observerRef = useRef<IntersectionObserver>()
  const lastElementRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (isFetchingNextPage) return
      if (observerRef.current) observerRef.current.disconnect()
      observerRef.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && hasNextPage) {
          fetchNextPage()
        }
      })
      if (node) observerRef.current.observe(node)
    },
    [isFetchingNextPage, hasNextPage, fetchNextPage]
  )

  if (status === 'pending') return <div>Loading projects...</div>
  if (status === 'error') return <div>Error loading projects</div>

  return (
    <div>
      {data.pages.map((page, pageIndex) => (
        <div key={pageIndex}>
          {page.data.map((project, index) => {
            const isLast =
              pageIndex === data.pages.length - 1 &&
              index === page.data.length - 1
            return (
              <div key={project.id} ref={isLast ? lastElementRef : undefined}>
                {project.name}
              </div>
            )
          })}
        </div>
      ))}
      {isFetchingNextPage && <div>Loading more...</div>}
    </div>
  )
}
```

## QueryClient Methods - Cache Management

The QueryClient provides methods for directly interacting with the cache, including prefetching, invalidation, and manual data updates.

```tsx
import { useQueryClient } from '@tanstack/react-query'

function CacheManagement() {
  const queryClient = useQueryClient()

  // Prefetch data before it's needed
  const prefetchUser = async (userId: number) => {
    await queryClient.prefetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
      staleTime: 1000 * 60 * 5, // Consider fresh for 5 minutes
    })
  }

  // Invalidate queries to trigger refetch
  const refreshAllUsers = () => {
    queryClient.invalidateQueries({ queryKey: ['users'] })
  }

  // Invalidate specific query
  const refreshUser = (userId: number) => {
    queryClient.invalidateQueries({ queryKey: ['user', userId] })
  }

  // Get cached data synchronously
  const getCachedUser = (userId: number) => {
    return queryClient.getQueryData(['user', userId])
  }

  // Set data directly in cache
  const updateCachedUser = (userId: number, newData: any) => {
    queryClient.setQueryData(['user', userId], newData)
  }

  // Remove queries from cache
  const clearUserCache = () => {
    queryClient.removeQueries({ queryKey: ['users'] })
  }

  // Cancel in-flight queries
  const cancelUserFetch = async (userId: number) => {
    await queryClient.cancelQueries({ queryKey: ['user', userId] })
  }

  // Fetch and return data (throws on error)
  const fetchUser = async (userId: number) => {
    return queryClient.fetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
    })
  }

  // Ensure data exists, fetch if needed
  const ensureUserData = async (userId: number) => {
    return queryClient.ensureQueryData({
      queryKey: ['user', userId],
      queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
    })
  }

  return (
    <div>
      <button onMouseEnter={() => prefetchUser(1)}>Hover to Prefetch</button>
      <button onClick={refreshAllUsers}>Refresh All Users</button>
    </div>
  )
}
```

## Query Invalidation - Keeping Data Fresh

Query invalidation marks queries as stale and optionally triggers refetches. This is essential for maintaining data consistency after mutations.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'

function DataSynchronization() {
  const queryClient = useQueryClient()

  const updatePost = useMutation({
    mutationFn: (data: { id: number; title: string }) =>
      fetch(`/api/posts/${data.id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
      }),
    onSuccess: (data, variables) => {
      // Invalidate specific post
      queryClient.invalidateQueries({ queryKey: ['post', variables.id] })

      // Invalidate all queries starting with 'posts'
      queryClient.invalidateQueries({ queryKey: ['posts'] })

      // Invalidate with predicate function
      queryClient.invalidateQueries({
        predicate: (query) =>
          query.queryKey[0] === 'posts' &&
          (query.queryKey[1] as any)?.status === 'published',
      })

      // Invalidate but don't refetch (mark stale only)
      queryClient.invalidateQueries({
        queryKey: ['analytics'],
        refetchType: 'none',
      })

      // Invalidate and refetch even inactive queries
      queryClient.invalidateQueries({
        queryKey: ['dashboard'],
        refetchType: 'all',
      })
    },
  })

  return <button onClick={() => updatePost.mutate({ id: 1, title: 'New Title' })}>Update</button>
}
```

## useSuspenseQuery - React Suspense Integration

The useSuspenseQuery hook integrates with React Suspense for declarative loading states. Data is guaranteed to be defined when the component renders.

```tsx
import { Suspense } from 'react'
import { useSuspenseQuery, QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

interface Post {
  id: number
  title: string
  body: string
}

function PostContent({ postId }: { postId: number }) {
  // data is guaranteed to be defined - no isPending check needed
  const { data } = useSuspenseQuery<Post>({
    queryKey: ['post', postId],
    queryFn: async () => {
      const response = await fetch(`/api/posts/${postId}`)
      if (!response.ok) throw new Error('Failed to fetch post')
      return response.json()
    },
  })

  return (
    <article>
      <h1>{data.title}</h1>
      <p>{data.body}</p>
    </article>
  )
}

function PostPage({ postId }: { postId: number }) {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ resetErrorBoundary, error }) => (
            <div>
              <p>Error: {error.message}</p>
              <button onClick={resetErrorBoundary}>Try Again</button>
            </div>
          )}
        >
          <Suspense fallback={<div>Loading post...</div>}>
            <PostContent postId={postId} />
          </Suspense>
        </ErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  )
}
```

## Dependent Queries - Sequential Data Fetching

Dependent queries wait for previous queries to complete before executing, useful when one query's result is needed for another.

```tsx
import { useQuery } from '@tanstack/react-query'

interface User {
  id: number
  name: string
}

interface UserProjects {
  projectId: number
  name: string
}

function UserDashboard({ userId }: { userId: number }) {
  // First query - fetch user
  const userQuery = useQuery<User>({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
  })

  // Second query - depends on user data
  const projectsQuery = useQuery<UserProjects[]>({
    queryKey: ['projects', userQuery.data?.id],
    queryFn: () =>
      fetch(`/api/users/${userQuery.data?.id}/projects`).then((r) => r.json()),
    enabled: !!userQuery.data?.id, // Only run when user data exists
  })

  if (userQuery.isPending) return <div>Loading user...</div>
  if (userQuery.isError) return <div>Error loading user</div>

  return (
    <div>
      <h1>Welcome, {userQuery.data.name}</h1>
      {projectsQuery.isPending ? (
        <div>Loading projects...</div>
      ) : projectsQuery.isError ? (
        <div>Error loading projects</div>
      ) : (
        <ul>
          {projectsQuery.data?.map((project) => (
            <li key={project.projectId}>{project.name}</li>
          ))}
        </ul>
      )}
    </div>
  )
}
```

## Prefetching - Performance Optimization

Prefetching loads data before it's needed, improving perceived performance by having data ready when users navigate.

```tsx
import { useQuery, useQueryClient } from '@tanstack/react-query'

interface Article {
  id: number
  title: string
  excerpt: string
}

function ArticleList() {
  const queryClient = useQueryClient()

  const { data: articles } = useQuery<Article[]>({
    queryKey: ['articles'],
    queryFn: () => fetch('/api/articles').then((r) => r.json()),
  })

  // Prefetch article details on hover
  const prefetchArticle = (articleId: number) => {
    queryClient.prefetchQuery({
      queryKey: ['article', articleId],
      queryFn: () => fetch(`/api/articles/${articleId}`).then((r) => r.json()),
      staleTime: 1000 * 60 * 5, // Keep prefetched data fresh for 5 minutes
    })
  }

  return (
    <ul>
      {articles?.map((article) => (
        <li
          key={article.id}
          onMouseEnter={() => prefetchArticle(article.id)}
          onFocus={() => prefetchArticle(article.id)}
        >
          <a href={`/articles/${article.id}`}>{article.title}</a>
          <p>{article.excerpt}</p>
        </li>
      ))}
    </ul>
  )
}
```

## Query Options Factory - Reusable Query Definitions

Query options factories create reusable, type-safe query configurations that can be shared across components.

```tsx
import { queryOptions, useQuery, useQueryClient } from '@tanstack/react-query'

interface Todo {
  id: number
  title: string
  completed: boolean
}

// Define reusable query options
const todosQueryOptions = queryOptions({
  queryKey: ['todos'],
  queryFn: async (): Promise<Todo[]> => {
    const response = await fetch('/api/todos')
    return response.json()
  },
  staleTime: 1000 * 60,
})

const todoQueryOptions = (todoId: number) =>
  queryOptions({
    queryKey: ['todo', todoId],
    queryFn: async (): Promise<Todo> => {
      const response = await fetch(`/api/todos/${todoId}`)
      return response.json()
    },
  })

// Use in components
function TodoList() {
  const { data } = useQuery(todosQueryOptions)
  return <ul>{data?.map((todo) => <li key={todo.id}>{todo.title}</li>)}</ul>
}

function TodoDetail({ todoId }: { todoId: number }) {
  const { data } = useQuery(todoQueryOptions(todoId))
  return <div>{data?.title}</div>
}

// Use for prefetching
function Navigation() {
  const queryClient = useQueryClient()

  const prefetchTodos = () => {
    queryClient.prefetchQuery(todosQueryOptions)
  }

  return <button onMouseEnter={prefetchTodos}>View Todos</button>
}
```

## Select and Transform Data

The select option transforms or extracts portions of query data without affecting what's stored in the cache.

```tsx
import { useQuery } from '@tanstack/react-query'
import { useCallback } from 'react'

interface User {
  id: number
  name: string
  email: string
  role: string
  createdAt: string
}

function UserStats() {
  // Select only specific fields
  const { data: adminCount } = useQuery({
    queryKey: ['users'],
    queryFn: (): Promise<User[]> => fetch('/api/users').then((r) => r.json()),
    select: useCallback(
      (users: User[]) => users.filter((u) => u.role === 'admin').length,
      []
    ),
  })

  // Transform data structure
  const { data: userMap } = useQuery({
    queryKey: ['users'],
    queryFn: (): Promise<User[]> => fetch('/api/users').then((r) => r.json()),
    select: useCallback(
      (users: User[]) =>
        users.reduce(
          (acc, user) => ({ ...acc, [user.id]: user }),
          {} as Record<number, User>
        ),
      []
    ),
  })

  // Extract single value
  const { data: latestUser } = useQuery({
    queryKey: ['users'],
    queryFn: (): Promise<User[]> => fetch('/api/users').then((r) => r.json()),
    select: useCallback(
      (users: User[]) =>
        users.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )[0],
      []
    ),
  })

  return (
    <div>
      <p>Admin count: {adminCount}</p>
      <p>Latest user: {latestUser?.name}</p>
    </div>
  )
}
```

## Parallel Queries - Concurrent Data Fetching

Fetch multiple independent queries simultaneously for optimal performance.

```tsx
import { useQueries, useQuery } from '@tanstack/react-query'

interface DashboardData {
  users: any[]
  posts: any[]
  comments: any[]
}

// Using multiple useQuery hooks (parallel by default)
function Dashboard() {
  const usersQuery = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then((r) => r.json()),
  })

  const postsQuery = useQuery({
    queryKey: ['posts'],
    queryFn: () => fetch('/api/posts').then((r) => r.json()),
  })

  const commentsQuery = useQuery({
    queryKey: ['comments'],
    queryFn: () => fetch('/api/comments').then((r) => r.json()),
  })

  const isLoading =
    usersQuery.isPending || postsQuery.isPending || commentsQuery.isPending

  if (isLoading) return <div>Loading dashboard...</div>

  return (
    <div>
      <UsersList users={usersQuery.data} />
      <PostsList posts={postsQuery.data} />
      <CommentsList comments={commentsQuery.data} />
    </div>
  )
}

// Using useQueries for dynamic parallel queries
function MultiUserProfiles({ userIds }: { userIds: number[] }) {
  const userQueries = useQueries({
    queries: userIds.map((id) => ({
      queryKey: ['user', id],
      queryFn: () => fetch(`/api/users/${id}`).then((r) => r.json()),
    })),
  })

  const isLoading = userQueries.some((query) => query.isPending)
  const isError = userQueries.some((query) => query.isError)

  if (isLoading) return <div>Loading users...</div>
  if (isError) return <div>Error loading some users</div>

  return (
    <div>
      {userQueries.map((query, index) => (
        <div key={userIds[index]}>{query.data?.name}</div>
      ))}
    </div>
  )
}
```

## Summary

TanStack Query excels at managing server state in modern web applications, providing a robust solution for data fetching, caching, and synchronization. The primary use cases include fetching and displaying API data with automatic caching, implementing infinite scroll and pagination, performing CRUD operations with optimistic updates, prefetching data for improved navigation performance, and synchronizing server state across components. The library integrates seamlessly with React Suspense and Error Boundaries for declarative loading and error handling, while also supporting offline scenarios through mutation persistence and automatic retry mechanisms.

Integration patterns typically involve setting up a QueryClientProvider at the application root with appropriate default options for staleTime, gcTime, and retry behavior. Queries are organized using query option factories for reusability, and mutations leverage callbacks like onSuccess and onSettled to maintain cache consistency through invalidation. For complex applications, TanStack Query integrates with routing libraries for route-level data prefetching and supports Server-Side Rendering through hydration APIs. The library's framework-agnostic core enables consistent patterns across React, Vue, Solid, Svelte, and Angular, making it an excellent choice for teams working across multiple frameworks or migrating between them.
