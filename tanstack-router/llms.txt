# TanStack Router & Start

TanStack Router is a modern, type-safe router for React, Solid, and Vue applications. It provides end-to-end type safety for routes, params, and loaders, along with schema-driven search params validation, built-in caching with SWR (stale-while-revalidate) support, prefetching, nested layouts, transitions, and error boundaries. The router's file-based routing system automatically generates a fully typed route tree, enabling powerful developer experiences with autocomplete and compile-time validation.

TanStack Start is a full-stack framework built on TanStack Router, designed for server rendering, streaming, and production-ready deployments. It provides full-document SSR, server functions with end-to-end type safety, middleware support, and deployment-ready bundling via Vite. Start enables seamless RPC-style communication between client and server while maintaining complete type safety across the network boundary.

## createRouter

The `createRouter` function creates a new router instance that manages navigation, route matching, and data loading. It accepts a route tree (generated from file-based routes or manually defined) and configuration options for preloading, caching, and default behaviors.

```tsx
import { createRouter, RouterProvider } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'

const router = createRouter({
  routeTree,
  defaultPreload: 'intent',
  defaultStaleTime: 5000,
  defaultPreloadStaleTime: 0,
})

// Register router for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}

export default function App() {
  return <RouterProvider router={router} />
}
```

## createRootRoute

The `createRootRoute` function creates the root route of your application. It serves as the parent for all other routes and typically includes your application shell with navigation, headers, and the Outlet component for rendering child routes.

```tsx
import { createRootRoute, Outlet, Link } from '@tanstack/react-router'

export const Route = createRootRoute({
  component: () => (
    <div>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/posts">Posts</Link>
      </nav>
      <main>
        <Outlet />
      </main>
    </div>
  ),
  notFoundComponent: () => <div>404 Not Found</div>,
  errorComponent: ({ error }) => <div>Error: {error.message}</div>,
})
```

## createFileRoute

The `createFileRoute` function creates a file-based route instance. The route path is automatically managed by the TanStack Router CLI (`tsr generate` or `tsr watch`), which generates and updates routes based on your file structure.

```tsx
// src/routes/posts.$postId.tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/posts/$postId')({
  loader: async ({ params }) => {
    const response = await fetch(`/api/posts/${params.postId}`)
    if (!response.ok) throw new Error('Post not found')
    return response.json()
  },
  component: PostComponent,
})

function PostComponent() {
  const post = Route.useLoaderData()
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </article>
  )
}
```

## Route Loaders with Data Loading

Route loaders fetch data before rendering a route. They support caching, preloading, and parallel data fetching. Use `loaderDeps` to specify which search params should trigger a reload, and access data with `useLoaderData`.

```tsx
// src/routes/posts.tsx
import { createFileRoute } from '@tanstack/react-router'
import { z } from 'zod'

const searchSchema = z.object({
  page: z.number().catch(1),
  filter: z.string().catch(''),
})

export const Route = createFileRoute('/posts')({
  validateSearch: searchSchema,
  loaderDeps: ({ search: { page, filter } }) => ({ page, filter }),
  loader: async ({ deps: { page, filter }, abortController }) => {
    const response = await fetch(
      `/api/posts?page=${page}&filter=${filter}`,
      { signal: abortController.signal }
    )
    return response.json()
  },
  staleTime: 10_000, // Cache for 10 seconds
  pendingComponent: () => <div>Loading posts...</div>,
  errorComponent: ({ error, reset }) => (
    <div>
      <p>Error: {error.message}</p>
      <button onClick={reset}>Retry</button>
    </div>
  ),
  component: PostsComponent,
})

function PostsComponent() {
  const { posts, totalPages } = Route.useLoaderData()
  const { page } = Route.useSearch()

  return (
    <div>
      {posts.map(post => <PostCard key={post.id} post={post} />)}
      <p>Page {page} of {totalPages}</p>
    </div>
  )
}
```

## Link Component

The `Link` component creates type-safe navigation links with support for path params, search params, and hash fragments. It provides active state styling and preloading on hover or intent.

```tsx
import { Link } from '@tanstack/react-router'

function Navigation() {
  return (
    <nav>
      {/* Basic link */}
      <Link to="/">Home</Link>

      {/* Link with path params */}
      <Link to="/posts/$postId" params={{ postId: '123' }}>
        View Post
      </Link>

      {/* Link with search params */}
      <Link
        to="/posts"
        search={{ page: 2, filter: 'published' }}
      >
        Page 2
      </Link>

      {/* Update search params from current route */}
      <Link
        from="/posts"
        search={(prev) => ({ ...prev, page: prev.page + 1 })}
      >
        Next Page
      </Link>

      {/* Active link styling */}
      <Link
        to="/posts"
        activeProps={{ className: 'active' }}
        inactiveProps={{ className: 'inactive' }}
      >
        Posts
      </Link>

      {/* Preload on hover */}
      <Link to="/posts/$postId" params={{ postId: '456' }} preload="intent">
        Preload on Hover
      </Link>
    </nav>
  )
}
```

## useNavigate Hook

The `useNavigate` hook returns a function for programmatic navigation. It supports all the same options as the Link component and returns a Promise that resolves when navigation completes.

```tsx
import { useNavigate } from '@tanstack/react-router'

function SearchForm() {
  const navigate = useNavigate()

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    const query = formData.get('query') as string

    await navigate({
      to: '/search',
      search: { q: query, page: 1 },
    })
  }

  const goBack = () => navigate({ to: '..', from: '/posts/$postId' })

  const replaceHistory = () =>
    navigate({ to: '/dashboard', replace: true })

  return (
    <form onSubmit={handleSubmit}>
      <input name="query" type="search" />
      <button type="submit">Search</button>
    </form>
  )
}
```

## useParams Hook

The `useParams` hook returns the parsed path parameters for the current route. Use the `from` option for strict typing or `strict: false` for loose typing across multiple routes.

```tsx
import { useParams, getRouteApi } from '@tanstack/react-router'

// Option 1: Using from parameter
function PostDetail() {
  const { postId } = useParams({ from: '/posts/$postId' })
  return <div>Post ID: {postId}</div>
}

// Option 2: Using getRouteApi
const routeApi = getRouteApi('/posts/$postId')

function PostDetailAlt() {
  const { postId } = routeApi.useParams()
  return <div>Post ID: {postId}</div>
}

// Option 3: Loose params across routes
function SharedComponent() {
  const params = useParams({ strict: false })
  // params is Partial<AllParams> - may include postId, userId, etc.
  return <div>Params: {JSON.stringify(params)}</div>
}

// Option 4: Select specific param
function PostId() {
  const postId = useParams({
    from: '/posts/$postId',
    select: (params) => params.postId,
  })
  return <div>Post ID: {postId}</div>
}
```

## useSearch Hook

The `useSearch` hook returns the validated and typed search parameters for a route. Search params are automatically parsed from JSON-compatible URL format and validated through the route's `validateSearch` option.

```tsx
import { useSearch, getRouteApi } from '@tanstack/react-router'

const routeApi = getRouteApi('/products')

function ProductFilters() {
  const { page, sort, category } = routeApi.useSearch()

  // Or with from parameter
  const search = useSearch({ from: '/products' })

  // Select specific value
  const currentPage = useSearch({
    from: '/products',
    select: (s) => s.page,
  })

  // Loose search across all routes
  const looseSearch = useSearch({ strict: false })

  return (
    <div>
      <p>Page: {page}</p>
      <p>Sort: {sort}</p>
      <p>Category: {category}</p>
    </div>
  )
}
```

## useLoaderData Hook

The `useLoaderData` hook returns the data loaded by a route's loader function. It provides type-safe access to the resolved loader data.

```tsx
import { useLoaderData, getRouteApi } from '@tanstack/react-router'

const routeApi = getRouteApi('/posts/$postId')

function PostContent() {
  // Using getRouteApi
  const post = routeApi.useLoaderData()

  // Or with from parameter
  const postAlt = useLoaderData({ from: '/posts/$postId' })

  // Select specific data
  const title = useLoaderData({
    from: '/posts/$postId',
    select: (data) => data.title,
  })

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <span>Author: {post.author.name}</span>
    </article>
  )
}
```

## Search Params Validation with Zod

TanStack Router supports schema-based search param validation using Zod, Valibot, ArkType, or any Standard Schema compatible library. Use adapters for proper input/output type inference.

```tsx
import { createFileRoute } from '@tanstack/react-router'
import { fallback, zodValidator } from '@tanstack/zod-adapter'
import { z } from 'zod'

const productSearchSchema = z.object({
  page: fallback(z.number(), 1).default(1),
  pageSize: fallback(z.number(), 20).default(20),
  sort: fallback(z.enum(['price', 'name', 'date']), 'date').default('date'),
  order: fallback(z.enum(['asc', 'desc']), 'desc').default('desc'),
  category: z.string().optional(),
  minPrice: z.number().optional(),
  maxPrice: z.number().optional(),
})

export const Route = createFileRoute('/products')({
  validateSearch: zodValidator(productSearchSchema),
  component: ProductList,
})

function ProductList() {
  const { page, pageSize, sort, order, category } = Route.useSearch()

  return (
    <div>
      <Link
        from="/products"
        search={(prev) => ({ ...prev, page: prev.page + 1 })}
      >
        Next Page
      </Link>
      <Link
        from="/products"
        search={(prev) => ({ ...prev, sort: 'price', order: 'asc' })}
      >
        Sort by Price
      </Link>
    </div>
  )
}
```

## redirect Function

The `redirect` function creates a redirect object that can be thrown from loaders or `beforeLoad` to navigate users to different routes. It's commonly used for authentication guards and conditional navigation.

```tsx
import { createFileRoute, redirect } from '@tanstack/react-router'

export const Route = createFileRoute('/dashboard')({
  beforeLoad: async ({ context, location }) => {
    if (!context.auth.isAuthenticated) {
      throw redirect({
        to: '/login',
        search: {
          redirect: location.href,
        },
      })
    }
  },
  loader: async ({ context }) => {
    const user = await context.auth.getUser()

    if (!user.hasCompletedOnboarding) {
      throw redirect({ to: '/onboarding' })
    }

    return { user }
  },
})

// Using Route.redirect in file-based routes (auto-sets 'from')
export const SettingsRoute = createFileRoute('/dashboard/settings')({
  beforeLoad: ({ context }) => {
    if (!context.user.isAdmin) {
      throw Route.redirect({
        to: '../', // Relative redirect to /dashboard
      })
    }
  },
})
```

## useBlocker Hook

The `useBlocker` hook prevents navigation when certain conditions are met, useful for protecting unsaved form data. It can show custom confirmation dialogs or use the browser's native confirm dialog.

```tsx
import { useBlocker } from '@tanstack/react-router'
import { useState } from 'react'

function EditForm() {
  const [isDirty, setIsDirty] = useState(false)
  const [formData, setFormData] = useState({ title: '', content: '' })

  // With custom UI
  const { status, proceed, reset, next } = useBlocker({
    shouldBlockFn: () => isDirty,
    withResolver: true,
  })

  // Or with native confirm dialog
  useBlocker({
    shouldBlockFn: ({ next }) => {
      if (!isDirty) return false
      return !confirm('You have unsaved changes. Leave anyway?')
    },
  })

  return (
    <div>
      <form onChange={() => setIsDirty(true)}>
        <input
          value={formData.title}
          onChange={(e) => setFormData(f => ({ ...f, title: e.target.value }))}
        />
        <textarea
          value={formData.content}
          onChange={(e) => setFormData(f => ({ ...f, content: e.target.value }))}
        />
        <button type="submit">Save</button>
      </form>

      {status === 'blocked' && (
        <div className="modal">
          <p>You have unsaved changes!</p>
          <p>Navigate to {next.pathname}?</p>
          <button onClick={proceed}>Leave</button>
          <button onClick={reset}>Stay</button>
        </div>
      )}
    </div>
  )
}
```

## Route Context with beforeLoad

Route context enables dependency injection throughout your route tree. Use `createRootRouteWithContext` to type your context and `beforeLoad` to extend it at any route level.

```tsx
// src/routes/__root.tsx
import { createRootRouteWithContext, Outlet } from '@tanstack/react-router'

interface RouterContext {
  auth: AuthService
  queryClient: QueryClient
}

export const Route = createRootRouteWithContext<RouterContext>()({
  component: () => <Outlet />,
})

// src/routes/dashboard.tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/dashboard')({
  beforeLoad: async ({ context }) => {
    const user = await context.auth.getUser()
    return {
      user,
      permissions: await fetchPermissions(user.id),
    }
  },
  loader: ({ context }) => {
    // context now includes user and permissions
    return fetchDashboardData(context.user.id)
  },
})

// src/router.tsx
import { createRouter } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'

const router = createRouter({
  routeTree,
  context: {
    auth: authService,
    queryClient: queryClient,
  },
})
```

## Outlet Component

The `Outlet` component renders the matched child route's component within a parent route. It's essential for nested layouts and enables hierarchical UI composition.

```tsx
import { createFileRoute, Outlet, Link } from '@tanstack/react-router'

// Parent layout route
export const Route = createFileRoute('/dashboard')({
  component: DashboardLayout,
})

function DashboardLayout() {
  return (
    <div className="dashboard">
      <aside>
        <nav>
          <Link to="/dashboard">Overview</Link>
          <Link to="/dashboard/analytics">Analytics</Link>
          <Link to="/dashboard/settings">Settings</Link>
        </nav>
      </aside>
      <main>
        <Outlet /> {/* Child routes render here */}
      </main>
    </div>
  )
}

// Child routes automatically nest inside the Outlet
// src/routes/dashboard.index.tsx -> renders at /dashboard
// src/routes/dashboard.analytics.tsx -> renders at /dashboard/analytics
```

## createServerFn (TanStack Start)

Server functions in TanStack Start enable type-safe RPC between client and server. They can access databases, environment variables, and server-only APIs while maintaining full type safety.

```tsx
import { createServerFn } from '@tanstack/react-start'
import { z } from 'zod'
import { db } from '~/db'

// Simple server function
export const getServerTime = createServerFn().handler(async () => {
  return new Date().toISOString()
})

// With input validation
export const getUser = createServerFn({ method: 'GET' })
  .inputValidator(z.object({ userId: z.string() }))
  .handler(async ({ data }) => {
    const user = await db.users.findUnique({ where: { id: data.userId } })
    if (!user) throw new Error('User not found')
    return user
  })

// POST with mutation
export const createPost = createServerFn({ method: 'POST' })
  .inputValidator(z.object({
    title: z.string().min(1),
    content: z.string().min(10),
  }))
  .handler(async ({ data }) => {
    const post = await db.posts.create({ data })
    return post
  })

// Usage in components
function UserProfile({ userId }: { userId: string }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => getUser({ data: { userId } }),
  })

  return <div>{user?.name}</div>
}

// Usage in loaders
export const Route = createFileRoute('/posts/$postId')({
  loader: ({ params }) => getPost({ data: { postId: params.postId } }),
})
```

## Server Function Error Handling and Redirects

Server functions can throw errors, redirects, and not-found responses that are automatically handled by the router when called from route lifecycles.

```tsx
import { createServerFn } from '@tanstack/react-start'
import { redirect, notFound } from '@tanstack/react-router'
import { getRequestHeader } from '@tanstack/react-start/server'

export const requireAuth = createServerFn().handler(async () => {
  const authHeader = getRequestHeader('Authorization')

  if (!authHeader) {
    throw redirect({ to: '/login' })
  }

  const user = await validateToken(authHeader)

  if (!user) {
    throw redirect({
      to: '/login',
      search: { error: 'session_expired' },
    })
  }

  return user
})

export const getPost = createServerFn({ method: 'GET' })
  .inputValidator((data: { postId: string }) => data)
  .handler(async ({ data }) => {
    const post = await db.posts.findUnique({
      where: { id: data.postId },
    })

    if (!post) {
      throw notFound()
    }

    if (post.status === 'draft') {
      throw new Error('Post not published')
    }

    return post
  })

// In route loader - errors/redirects handled automatically
export const Route = createFileRoute('/posts/$postId')({
  beforeLoad: () => requireAuth(),
  loader: ({ params }) => getPost({ data: { postId: params.postId } }),
  errorComponent: ({ error }) => <div>Error: {error.message}</div>,
  notFoundComponent: () => <div>Post not found</div>,
})
```

## Middleware (TanStack Start)

Middleware enables composable request/response handling for server functions and routes. It supports authentication, logging, context injection, and request modification.

```tsx
import { createMiddleware, createServerFn } from '@tanstack/react-start'
import { zodValidator } from '@tanstack/zod-adapter'
import { z } from 'zod'

// Logging middleware
const loggingMiddleware = createMiddleware().server(async ({ next }) => {
  const start = Date.now()
  const result = await next()
  console.log(`Request took ${Date.now() - start}ms`)
  return result
})

// Auth middleware with context
const authMiddleware = createMiddleware().server(async ({ next }) => {
  const user = await getCurrentUser()
  return next({
    context: { user },
  })
})

// Input validation middleware
const workspaceMiddleware = createMiddleware({ type: 'function' })
  .inputValidator(zodValidator(z.object({ workspaceId: z.string() })))
  .server(async ({ next, data, context }) => {
    const workspace = await db.workspaces.findUnique({
      where: { id: data.workspaceId, userId: context.user.id },
    })

    if (!workspace) throw new Error('Workspace not found')

    return next({
      context: { workspace },
    })
  })

// Composing middleware
export const getWorkspaceData = createServerFn({ method: 'GET' })
  .middleware([loggingMiddleware, authMiddleware, workspaceMiddleware])
  .handler(async ({ context }) => {
    // context.user and context.workspace are available
    return db.data.findMany({
      where: { workspaceId: context.workspace.id },
    })
  })

// Global middleware in src/start.ts
import { createStart, createMiddleware } from '@tanstack/react-start'

const globalAuth = createMiddleware().server(async ({ next }) => {
  // Runs for every request
  return next()
})

export const startInstance = createStart(() => ({
  requestMiddleware: [globalAuth],
}))
```

## Server Context Utilities

Access and modify request/response data within server functions using context utilities. These enable header manipulation, cookie access, and cache control.

```tsx
import { createServerFn } from '@tanstack/react-start'
import {
  getRequest,
  getRequestHeader,
  setResponseHeader,
  setResponseHeaders,
  setResponseStatus,
} from '@tanstack/react-start/server'

export const getCachedData = createServerFn({ method: 'GET' }).handler(
  async () => {
    // Access request
    const request = getRequest()
    const authHeader = getRequestHeader('Authorization')
    const userAgent = getRequestHeader('User-Agent')

    // Set cache headers
    setResponseHeaders(new Headers({
      'Cache-Control': 'public, max-age=300',
      'CDN-Cache-Control': 'max-age=3600',
    }))

    // Set individual header
    setResponseHeader('X-Custom-Header', 'value')

    // Set status code
    setResponseStatus(200)

    return fetchData()
  }
)

// Cookie handling example
export const getUserPreferences = createServerFn().handler(async () => {
  const request = getRequest()
  const cookies = request.headers.get('Cookie')
  const theme = parseCookie(cookies, 'theme') || 'light'

  setResponseHeader(
    'Set-Cookie',
    `lastVisit=${Date.now()}; Path=/; HttpOnly`
  )

  return { theme }
})
```

## File-Based Routing Configuration

Configure file-based routing through `tsr.config.json` to customize route generation, code splitting, and file naming conventions.

```json
{
  "routesDirectory": "./src/routes",
  "generatedRouteTree": "./src/routeTree.gen.ts",
  "routeFileIgnorePrefix": "-",
  "routeFileIgnorePattern": "\\.(test|spec)\\.",
  "quoteStyle": "single",
  "semicolons": false,
  "autoCodeSplitting": true
}
```

```
Project structure example:
src/routes/
├── __root.tsx           # Root layout
├── index.tsx            # Home page (/)
├── posts.tsx            # Posts layout (/posts)
├── posts.index.tsx      # Posts list (/posts)
├── posts.$postId.tsx    # Post detail (/posts/:postId)
├── posts_.$postId.edit.tsx  # Edit post (pathless layout)
├── _auth.tsx            # Auth layout (pathless)
├── _auth.login.tsx      # Login (/login)
├── _auth.register.tsx   # Register (/register)
├── dashboard/
│   ├── route.tsx        # Dashboard layout (/dashboard)
│   ├── index.tsx        # Dashboard home (/dashboard)
│   ├── -components/     # Ignored (starts with -)
│   │   └── Chart.tsx
│   └── analytics.tsx    # Analytics (/dashboard/analytics)
```

## Summary

TanStack Router and Start provide a comprehensive solution for building type-safe, full-stack React applications. The router excels at client-side navigation with its file-based routing, powerful search param handling, built-in caching, and data loading primitives. Key patterns include using `createFileRoute` for file-based routes, `validateSearch` with Zod for type-safe URL state, and `loaderDeps` for proper cache keying. The nested layout system with `Outlet` enables complex UI compositions while maintaining clean code organization.

TanStack Start extends these capabilities to the server with `createServerFn` for type-safe RPCs, middleware for request/response handling, and seamless integration with the router's data loading system. Common integration patterns include using server functions in route loaders for SSR data fetching, middleware for authentication and authorization, and the redirect/notFound utilities for navigation control. Together, these tools provide a complete framework for building modern web applications with excellent developer experience and runtime type safety.
