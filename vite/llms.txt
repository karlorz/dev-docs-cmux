# Vite

Vite is a next-generation frontend build tool that provides a faster and leaner development experience for modern web projects. It consists of two major components: a dev server that serves source files over native ES modules with lightning-fast Hot Module Replacement (HMR), and a build command that bundles code with Rolldown for highly optimized static assets in production. Vite supports TypeScript, JSX, CSS preprocessors, and various frameworks out of the box.

The architecture leverages native ES modules in the browser during development, eliminating the need for bundling and enabling instant server start. Dependencies are pre-bundled using esbuild for faster cold starts, while application source code is served on-demand. The plugin system extends Rolldown's interface with Vite-specific hooks, allowing seamless integration with the ecosystem of Rollup/Rolldown plugins.

## Creating a New Vite Project

Scaffold a new project using the `create-vite` command. This creates a project with pre-configured settings for your chosen framework including React, Vue, Svelte, or vanilla JavaScript/TypeScript.

```bash
# Using npm
npm create vite@latest my-app -- --template react-ts

# Using pnpm
pnpm create vite my-app --template vue

# Using yarn
yarn create vite my-app --template svelte-ts

# Using bun
bun create vite my-app --template vanilla

# Available templates: vanilla, vanilla-ts, vue, vue-ts, react, react-ts,
# react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts,
# solid, solid-ts, qwik, qwik-ts
```

## Configuration with defineConfig

Create a `vite.config.js` or `vite.config.ts` file in your project root. The `defineConfig` helper provides TypeScript intellisense and type checking for configuration options.

```typescript
// vite.config.ts
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig(({ command, mode }) => {
  // Load env variables based on mode
  const env = loadEnv(mode, process.cwd(), '')

  return {
    plugins: [react()],
    root: './src',
    base: '/my-app/',

    // Define global constants
    define: {
      __APP_VERSION__: JSON.stringify('1.0.0'),
      __API_URL__: JSON.stringify(env.API_URL),
    },

    // Path resolution
    resolve: {
      alias: {
        '@': '/src',
        '@components': '/src/components',
      },
    },

    // Development server
    server: {
      port: 3000,
      open: true,
      proxy: {
        '/api': {
          target: 'http://localhost:8080',
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/api/, ''),
        },
      },
    },

    // Build configuration
    build: {
      outDir: '../dist',
      sourcemap: true,
      minify: 'oxc',
      rolldownOptions: {
        output: {
          entryFileNames: 'assets/[name].[hash].js',
        },
      },
    },
  }
})
```

## CLI Commands

Vite provides CLI commands for development, building, and previewing your application. Each command supports various options for customization.

```bash
# Start development server
vite
vite --port 3000 --host 0.0.0.0
vite --config custom.config.js

# Build for production
vite build
vite build --outDir build --sourcemap
vite build --mode staging

# Preview production build locally
vite preview
vite preview --port 4173

# Common CLI options
# --config <file>     Use specified config file
# --base <path>       Public base path (default: /)
# --mode <mode>       Set env mode (development/production/custom)
# --logLevel <level>  info | warn | error | silent
# --clearScreen       Allow/disable clear screen when logging
# --force             Force optimizer to ignore cache and re-bundle
```

## JavaScript API - createServer

Programmatically create and control a Vite development server. Useful for testing, custom server setups, or integrating Vite into existing applications.

```typescript
import { createServer, ViteDevServer } from 'vite'

async function startDevServer(): Promise<ViteDevServer> {
  const server = await createServer({
    configFile: false,
    root: process.cwd(),
    server: {
      port: 3000,
      strictPort: true,
      hmr: {
        overlay: true,
      },
    },
    optimizeDeps: {
      include: ['react', 'react-dom'],
    },
  })

  await server.listen()
  server.printUrls()
  server.bindCLIShortcuts({ print: true })

  // Access server internals
  console.log('Resolved config:', server.config)
  console.log('HTTP server:', server.httpServer)

  // Transform a file programmatically
  const result = await server.transformRequest('/src/main.ts')
  console.log('Transformed code:', result?.code)

  // Graceful shutdown
  process.on('SIGTERM', async () => {
    await server.close()
    process.exit(0)
  })

  return server
}

startDevServer()
```

## JavaScript API - build

Programmatically trigger production builds with full control over the build process and output.

```typescript
import { build, BuildOptions } from 'vite'
import path from 'node:path'

async function runBuild() {
  const result = await build({
    root: path.resolve(__dirname, './project'),
    base: '/app/',
    build: {
      outDir: 'dist',
      emptyOutDir: true,
      sourcemap: true,
      minify: 'oxc',
      target: 'es2020',
      lib: {
        entry: path.resolve(__dirname, 'src/index.ts'),
        name: 'MyLibrary',
        formats: ['es', 'cjs', 'umd'],
        fileName: (format) => `my-library.${format}.js`,
      },
      rolldownOptions: {
        external: ['react', 'react-dom'],
        output: {
          globals: {
            react: 'React',
            'react-dom': 'ReactDOM',
          },
        },
      },
    },
  })

  console.log('Build complete:', result)
}

runBuild()
```

## JavaScript API - preview

Start a preview server for the production build to test it locally before deployment.

```typescript
import { preview, build } from 'vite'

async function buildAndPreview() {
  // First build the project
  await build({
    build: { outDir: 'dist' },
  })

  // Then preview the built files
  const previewServer = await preview({
    preview: {
      port: 4173,
      strictPort: true,
      open: true,
      host: true,
    },
  })

  previewServer.printUrls()
  previewServer.bindCLIShortcuts({ print: true })

  // Access the server
  console.log('Preview URL:', previewServer.resolvedUrls)
}

buildAndPreview()
```

## Plugin API - Basic Plugin Structure

Create custom Vite plugins to transform code, add virtual modules, or configure the dev server. Plugins follow Rolldown's plugin interface with additional Vite-specific hooks.

```typescript
import type { Plugin, ResolvedConfig } from 'vite'

export default function myPlugin(options: { prefix?: string } = {}): Plugin {
  let config: ResolvedConfig

  return {
    name: 'vite-plugin-my-plugin',
    enforce: 'pre', // 'pre' | 'post' | undefined
    apply: 'serve', // 'serve' | 'build' | undefined

    // Modify config before resolution
    config(userConfig, { command, mode }) {
      return {
        define: {
          __PLUGIN_ENABLED__: true,
        },
      }
    },

    // Access final resolved config
    configResolved(resolvedConfig) {
      config = resolvedConfig
      console.log('Root:', config.root)
      console.log('Command:', config.command)
    },

    // Transform source code
    transform(code, id) {
      if (id.endsWith('.custom')) {
        return {
          code: `export default ${JSON.stringify(code)}`,
          map: null,
        }
      }
    },

    // Resolve module IDs
    resolveId(id) {
      if (id === 'virtual:my-module') {
        return '\0virtual:my-module'
      }
    },

    // Load virtual modules
    load(id) {
      if (id === '\0virtual:my-module') {
        return `export const message = "${options.prefix || 'Hello'} from virtual module"`
      }
    },
  }
}
```

## Plugin API - configureServer Hook

Configure the development server by adding custom middleware, handling WebSocket events, or modifying server behavior.

```typescript
import type { Plugin, ViteDevServer } from 'vite'

export default function serverPlugin(): Plugin {
  return {
    name: 'vite-plugin-server',

    configureServer(server: ViteDevServer) {
      // Add middleware before Vite's internal middleware
      server.middlewares.use('/health', (req, res) => {
        res.end('OK')
      })

      // Return a function to add middleware after internal middleware
      return () => {
        server.middlewares.use((req, res, next) => {
          // Custom 404 handling
          if (!res.writableEnded) {
            res.statusCode = 404
            res.end('Not Found')
          }
        })
      }
    },

    // Configure preview server similarly
    configurePreviewServer(server) {
      server.middlewares.use('/api/info', (req, res) => {
        res.setHeader('Content-Type', 'application/json')
        res.end(JSON.stringify({ version: '1.0.0' }))
      })
    },
  }
}
```

## Plugin API - transformIndexHtml Hook

Transform HTML entry files by injecting scripts, styles, or modifying the HTML structure.

```typescript
import type { Plugin, IndexHtmlTransformContext } from 'vite'

export default function htmlPlugin(): Plugin {
  return {
    name: 'vite-plugin-html',

    transformIndexHtml: {
      order: 'pre', // 'pre' | 'post' | undefined
      handler(html: string, ctx: IndexHtmlTransformContext) {
        // Return transformed HTML string
        const transformed = html.replace(
          '</head>',
          `<script>window.BUILD_TIME = "${new Date().toISOString()}"</script></head>`
        )

        // Or return tag descriptors
        return {
          html: transformed,
          tags: [
            {
              tag: 'link',
              attrs: { rel: 'preconnect', href: 'https://api.example.com' },
              injectTo: 'head',
            },
            {
              tag: 'script',
              attrs: { type: 'module' },
              children: 'console.log("Injected!")',
              injectTo: 'body',
            },
          ],
        }
      },
    },
  }
}
```

## Plugin API - handleHotUpdate Hook

Customize Hot Module Replacement behavior by filtering affected modules or sending custom events to the client.

```typescript
import type { Plugin, HmrContext, ModuleNode } from 'vite'

export default function hmrPlugin(): Plugin {
  return {
    name: 'vite-plugin-hmr',

    handleHotUpdate(ctx: HmrContext) {
      const { file, timestamp, modules, read, server } = ctx

      // Ignore certain file changes
      if (file.endsWith('.test.ts')) {
        return []
      }

      // Custom handling for specific files
      if (file.endsWith('.config.json')) {
        // Send custom event to client
        server.ws.send({
          type: 'custom',
          event: 'config-update',
          data: { file, timestamp },
        })
        // Prevent default HMR
        return []
      }

      // Filter affected modules
      const filteredModules = modules.filter((mod: ModuleNode) => {
        return !mod.id?.includes('node_modules')
      })

      // Force full reload for certain changes
      if (file.includes('/critical/')) {
        server.ws.send({ type: 'full-reload' })
        return []
      }

      return filteredModules
    },
  }
}
```

## HMR API - Client-Side Hot Module Replacement

Use the HMR API in your application code to handle module updates, preserve state, and respond to HMR events.

```typescript
// counter.ts
let count = 0

export function increment() {
  count++
  render()
}

export function render() {
  document.getElementById('count')!.textContent = String(count)
}

// Self-accepting module with state preservation
if (import.meta.hot) {
  // Preserve state across updates
  if (import.meta.hot.data.count !== undefined) {
    count = import.meta.hot.data.count
  }

  // Accept updates to this module
  import.meta.hot.accept((newModule) => {
    if (newModule) {
      // Re-render with new code
      newModule.render()
    }
  })

  // Save state before update
  import.meta.hot.dispose((data) => {
    data.count = count
  })

  // Clean up when module is removed
  import.meta.hot.prune(() => {
    console.log('Module removed from page')
  })

  // Listen to HMR events
  import.meta.hot.on('vite:beforeUpdate', () => {
    console.log('Update incoming...')
  })

  // Custom events from plugins
  import.meta.hot.on('config-update', (data) => {
    console.log('Config changed:', data)
  })

  // Send events to server
  import.meta.hot.send('my:event', { message: 'Hello from client' })
}
```

## CSS and Preprocessors

Vite supports CSS imports with HMR, CSS Modules, and preprocessors like Sass, Less, and Stylus out of the box.

```typescript
// vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
  css: {
    // CSS Modules configuration
    modules: {
      localsConvention: 'camelCaseOnly',
      generateScopedName: '[name]__[local]___[hash:base64:5]',
    },

    // Preprocessor options
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/styles/variables.scss";`,
        includePaths: ['./src/styles'],
      },
      less: {
        math: 'parens-division',
        modifyVars: {
          'primary-color': '#1890ff',
        },
      },
    },

    // Enable Lightning CSS (experimental)
    transformer: 'lightningcss',
    lightningcss: {
      targets: {
        chrome: 111,
        firefox: 114,
        safari: 16,
      },
    },

    // Enable dev sourcemaps
    devSourcemap: true,
  },
})
```

```typescript
// Usage in application code
import styles from './Component.module.css'
import './global.css'
import scssStyles from './styles.module.scss'

// CSS Modules - scoped class names
document.getElementById('app')!.className = styles.container

// With camelCase convention
const element = document.createElement('div')
element.className = scssStyles.myClassName

// Inline CSS (not injected to page)
import inlineStyles from './inline.css?inline'
console.log(inlineStyles) // Raw CSS string
```

## Static Assets and Imports

Import and handle static assets with special query parameters for different use cases.

```typescript
// Import as URL (default for assets)
import imgUrl from './image.png'
document.getElementById('img')!.setAttribute('src', imgUrl)

// Import as string (raw content)
import shaderCode from './shader.glsl?raw'
console.log(shaderCode)

// Explicit URL import
import assetUrl from './data.json?url'
fetch(assetUrl).then(r => r.json())

// Import Web Worker
import Worker from './worker.ts?worker'
const worker = new Worker()
worker.postMessage({ type: 'start' })

// Inline worker as base64
import InlineWorker from './worker.ts?worker&inline'

// Dynamic imports with glob
const modules = import.meta.glob('./modules/*.ts')
for (const path in modules) {
  modules[path]().then((mod) => {
    console.log(path, mod)
  })
}

// Eager glob import (static)
const eagerModules = import.meta.glob('./components/*.vue', { eager: true })

// Import specific exports
const setups = import.meta.glob('./plugins/*.ts', {
  import: 'setup',
  eager: true,
})

// Glob with custom query
const svgUrls = import.meta.glob('./icons/*.svg', {
  query: '?url',
  import: 'default',
})
```

## Environment Variables

Access environment variables through `import.meta.env` with proper prefixing and type safety.

```typescript
// .env
// VITE_API_URL=https://api.example.com
// VITE_APP_TITLE=My App
// SECRET_KEY=should-not-be-exposed

// .env.production
// VITE_API_URL=https://api.production.com

// vite-env.d.ts - Type declarations
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
  readonly VITE_APP_TITLE: string
  readonly MODE: string
  readonly DEV: boolean
  readonly PROD: boolean
  readonly SSR: boolean
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

// Usage in application
console.log(import.meta.env.VITE_API_URL)
console.log(import.meta.env.MODE) // 'development' or 'production'
console.log(import.meta.env.DEV)  // true in dev
console.log(import.meta.env.PROD) // true in production

// Load env in config file
import { defineConfig, loadEnv } from 'vite'

export default defineConfig(({ mode }) => {
  // Load all env variables (not just VITE_ prefixed)
  const env = loadEnv(mode, process.cwd(), '')

  return {
    define: {
      'process.env.API_KEY': JSON.stringify(env.SECRET_KEY),
    },
  }
})
```

## Server-Side Rendering (SSR)

Configure Vite for server-side rendering with the development server and production builds.

```typescript
// vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    ssr: true,
    rolldownOptions: {
      input: './src/entry-server.ts',
    },
  },
  ssr: {
    // Externalize dependencies for SSR
    external: ['express'],
    // Bundle specific dependencies
    noExternal: ['my-ui-library'],
  },
})

// server.ts - Development server with SSR
import express from 'express'
import { createServer as createViteServer } from 'vite'

async function createServer() {
  const app = express()

  const vite = await createViteServer({
    server: { middlewareMode: true },
    appType: 'custom',
  })

  app.use(vite.middlewares)

  app.use('*', async (req, res) => {
    const url = req.originalUrl

    try {
      // Read and transform index.html
      let template = await fs.readFile('./index.html', 'utf-8')
      template = await vite.transformIndexHtml(url, template)

      // Load server entry
      const { render } = await vite.ssrLoadModule('/src/entry-server.ts')

      // Render the app
      const appHtml = await render(url)

      // Inject app HTML
      const html = template.replace('<!--app-html-->', appHtml)

      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
    } catch (e) {
      vite.ssrFixStacktrace(e as Error)
      console.error(e)
      res.status(500).end((e as Error).message)
    }
  })

  app.listen(3000)
}

createServer()
```

## Proxy Configuration

Configure development server proxy for API requests and WebSocket connections.

```typescript
// vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
  server: {
    proxy: {
      // Simple string shorthand
      '/foo': 'http://localhost:4567',

      // With options
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
        secure: false,
        headers: {
          'X-Custom-Header': 'value',
        },
        configure: (proxy, options) => {
          proxy.on('proxyReq', (proxyReq, req, res) => {
            console.log('Proxying:', req.url)
          })
          proxy.on('error', (err, req, res) => {
            console.error('Proxy error:', err)
          })
        },
      },

      // WebSocket proxy
      '/socket.io': {
        target: 'ws://localhost:5174',
        ws: true,
        rewriteWsOrigin: true,
      },

      // RegExp matching
      '^/api/v[0-9]+/.*': {
        target: 'http://api.example.com',
        changeOrigin: true,
      },
    },
  },
})
```

## Library Mode

Build your project as a library for distribution via npm with proper entry points and external dependencies.

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import { resolve } from 'path'
import dts from 'vite-plugin-dts'

export default defineConfig({
  plugins: [
    dts({ include: ['src'] }), // Generate .d.ts files
  ],
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.ts'),
      name: 'MyLibrary',
      formats: ['es', 'cjs', 'umd'],
      fileName: (format) => `my-library.${format}.js`,
    },
    rolldownOptions: {
      // Externalize peer dependencies
      external: ['react', 'react-dom', 'vue'],
      output: {
        globals: {
          react: 'React',
          'react-dom': 'ReactDOM',
          vue: 'Vue',
        },
        // Preserve module structure for tree-shaking
        preserveModules: true,
        preserveModulesRoot: 'src',
      },
    },
    sourcemap: true,
    minify: false,
  },
})

// package.json configuration for library
/*
{
  "name": "my-library",
  "version": "1.0.0",
  "type": "module",
  "files": ["dist"],
  "main": "./dist/my-library.cjs.js",
  "module": "./dist/my-library.es.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/my-library.es.js",
      "require": "./dist/my-library.cjs.js",
      "types": "./dist/index.d.ts"
    }
  },
  "peerDependencies": {
    "react": "^18.0.0"
  }
}
*/
```

Vite is the foundational build tool for modern frontend development, powering meta-frameworks like Nuxt, SvelteKit, Astro, and Remix. Its plugin ecosystem is compatible with Rollup/Rolldown plugins, making it highly extensible for any build requirement. The development experience focuses on speed through native ES modules and intelligent dependency pre-bundling, while production builds leverage Rolldown for optimized output with tree-shaking, code splitting, and minification.

For integration with backend frameworks, Vite generates a manifest file mapping source files to their hashed output, enabling server-side template rendering with correct asset URLs. The middleware mode allows embedding Vite's development server into existing Node.js servers like Express or Koa. SSR support includes proper source map handling and the ability to load server modules programmatically through `ssrLoadModule`, making Vite suitable for both client-rendered SPAs and server-rendered applications.
