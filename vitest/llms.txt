### Example Vitest Setup File Configuration (TypeScript)

Source: https://main.vitest.dev/config/setupfiles

This example demonstrates how to configure setup files in Vitest using TypeScript. It shows how to import configuration, conditionally initialize a global setup, and reset state before each test.

```typescript
import { config } from '@some-testing-lib'

if (!globalThis.setupInitialized) {
  config.plugins = [myCoolPlugin]
  computeHeavyThing()
  globalThis.setupInitialized = true
}

// hooks reset before each test file
afterEach(() => {
  cleanup()
})

globalThis.resetBeforeEachTest = true
```

--------------------------------

### Global Setup and Teardown in Vitest

Source: https://main.vitest.dev/guide/lifecycle

Example of global setup and teardown functions in Vitest. The setup function runs once before all tests and can provide data to tests. The teardown function runs once after all tests complete.

```typescript
export function setup(project) {
  // Runs once before all tests
  console.log('Global setup')

  // Share data with tests
  project.provide('apiUrl', 'http://localhost:3000')
}

export function teardown() {
  // Runs once after all tests
  console.log('Global teardown')
}
```

--------------------------------

### Configure Vitest with Vite

Source: https://main.vitest.dev/guide

This example demonstrates how to configure Vitest when you are already using Vite. It includes a triple-slash directive to reference Vitest types and adds the 'test' property to the existing Vite configuration file. This allows Vitest to leverage Vite's setup.

```typescript
/// <reference types="vitest/config" />
import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    // ...
  },
})
```

--------------------------------

### Configure Different Browser Setups with Custom Options

Source: https://main.vitest.dev/guide/browser/multiple-setups

This example shows how to configure different setups for the same browser (Chromium). It allows specifying unique setup files (`setupFiles`) and providing custom values (`provide`) for each instance, enabling isolated test environments.

```typescript
import { defineConfig } from 'vitest/config'
import { playwright } from '@vitest/browser-playwright'

export default defineConfig({
  test: {
    browser: {
      enabled: true,
      provider: playwright(),
      headless: true,
      instances: [
        {
          browser: 'chromium',
          name: 'chromium-1',
          setupFiles: ['./ratio-setup.ts'],
          provide: {
            ratio: 1,
          },
        },
        {
          browser: 'chromium',
          name: 'chromium-2',
          provide: {
            ratio: 2,
          },
        },
      ],
    },
  },
})
```

```typescript
import { expect, inject, test } from 'vitest'
import { globalSetupModifier } from './example.js'

test('ratio works', () => {
  expect(inject('ratio') * globalSetupModifier).toBe(14)
})
```

--------------------------------

### Install Vitest UI

Source: https://main.vitest.dev/guide/ui

Installs the Vitest UI package as a development dependency using npm.

```bash
npm i -D @vitest/ui
```

--------------------------------

### Setup File Execution and Hooks in Vitest

Source: https://main.vitest.dev/guide/lifecycle

Demonstrates a Vitest setup file that runs before each test file. It logs a message and registers an afterEach hook for cleanup, ensuring consistent test environments.

```typescript
import { afterEach } from 'vitest'

// Runs before each test file
console.log('Setup file executing')

// Register hooks that apply to all tests
afterEach(() => {
  cleanup()
})
```

--------------------------------

### Merge Vite and Vitest Configurations

Source: https://main.vitest.dev/guide

This example illustrates how to merge separate Vite and Vitest configuration files using `mergeConfig`. It imports both configurations and combines them, allowing for distinct settings while maintaining a unified setup. This is useful when you need separate configurations but want to leverage shared Vite options.

```typescript
import { defineConfig, mergeConfig } from 'vitest/config'
import viteConfig from './vite.config.mjs'

export default mergeConfig(viteConfig, defineConfig({
  test: {
    // ...
  },
}))
```

```typescript
import { defineConfig } from 'vite'
import Vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [Vue()],
})
```

--------------------------------

### Start Vitest with UI

Source: https://main.vitest.dev/guide/ui

Launches Vitest tests with the integrated UI by using the `--ui` flag in the command line.

```bash
vitest --ui
```

--------------------------------

### Configure Vitest Projects

Source: https://main.vitest.dev/guide

This snippet shows how to configure multiple test projects within a single Vitest setup. The `projects` array in `vitest.config.ts` allows defining different configurations, environments, and setup files for various project parts or test types.

```typescript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: [
      // you can use a list of glob patterns to define your projects
      // Vitest expects a list of config files
      // or directories where there is a config file
      'packages/*',
      'tests/*/vitest.config.{e2e,unit}.ts',
      // you can even run the same tests,
      // but with different configs in the same "vitest" process
      {
        test: {
          name: 'happy-dom',
          root: './shared_tests',
          environment: 'happy-dom',
          setupFiles: ['./setup.happy-dom.ts'],
        },
      },
      {
        test: {
          name: 'node',
          root: './shared_tests',
          environment: 'node',
          setupFiles: ['./setup.node.ts'],
        },
      },
    ],
  },
})
```

--------------------------------

### Build and Link Local Vitest Modifications with pnpm

Source: https://main.vitest.dev/guide

Build and locally link your own modifications to Vitest. This process involves cloning the repository, installing dependencies, building the Vitest package, and then globally linking it. Finally, link the globally linked Vitest package into your project. Requires pnpm.

```bash
git clone https://github.com/vitest-dev/vitest.git
cd vitest
pnpm install
cd packages/vitest
pnpm run build
pnpm link --global
pnpm link --global vitest
```

--------------------------------

### Install Vitest using Package Managers

Source: https://main.vitest.dev/guide

Installs Vitest as a development dependency using common package managers like npm, yarn, pnpm, and bun. Vitest requires Vite version 6.0.0 or higher and Node.js version 20.0.0 or higher.

```bash
npm install -D vitest
```

```bash
yarn add -D vitest
```

```bash
pnpm add -D vitest
```

```bash
bun add -D vitest
```

--------------------------------

### Install Coverage Support Packages

Source: https://main.vitest.dev/guide/coverage

These commands demonstrate how to manually install the required packages for V8 or Istanbul code coverage support in Vitest. These are development dependencies.

```bash
npm i -D @vitest/coverage-v8
```

```bash
npm i -D @vitest/coverage-istanbul
```

--------------------------------

### Vitest: Complex Fixture Setup with Multiple `onCleanup` Calls (TypeScript)

Source: https://main.vitest.dev/guide/test-context

Illustrates a more complex Vitest fixture setup involving database connection and user creation, with cleanup logic registered for both. The `onCleanup` callback is used to ensure database disconnection and user deletion after the test scope ends. This example assumes the existence of `createDatabase`, `connect`, `disconnect`, `createTestUser`, and `deleteUser` functions.

```typescript
const test = baseTest
  .extend('database', { scope: 'file' }, async ({}, { onCleanup }) => {
    const db = await createDatabase()
    await db.connect()

    onCleanup(async () => {
      await db.disconnect()
    })

    return db
  })
  .extend('user', async ({ database }, { onCleanup }) => {
    const user = await database.createTestUser()

    onCleanup(async () => {
      await database.deleteUser(user.id)
    })

    return user
  })
```

--------------------------------

### Running Vitest via Package Managers (Shell)

Source: https://main.vitest.dev/guide/cli

Examples of how to invoke Vitest commands using different package managers like npm, pnpm, yarn, and bun, demonstrating tab completion usage.

```bash
npm vitest <Tab>
```

```bash
npm exec vitest <Tab>
```

```bash
pnpm vitest <Tab>
```

```bash
yarn vitest <Tab>
```

```bash
bun vitest <Tab>
```

--------------------------------

### Install Unreleased Vitest Commit via npm

Source: https://main.vitest.dev/guide

Install a specific unreleased commit of Vitest from the pkg.pr.new registry. This is useful for testing the latest changes or specific commit versions before they are officially released. Requires npm or a compatible package manager.

```bash
npm i https://pkg.pr.new/vitest@{commit}
```

--------------------------------

### Mocking Timers with Fake Timers in Vitest

Source: https://main.vitest.dev/guide/mocking/timers

This example demonstrates how to use Vitest's fake timers to mock `setTimeout` and `setInterval`. It includes setup with `beforeEach` to use fake timers and `afterEach` to restore mocks. The tests show how to run all timers, advance timers by a specific duration, and advance to the next timer to verify delayed function executions.

```javascript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

function executeAfterTwoHours(func) {
  setTimeout(func, 1000 * 60 * 60 * 2) // 2 hours
}

function executeEveryMinute(func) {
  setInterval(func, 1000 * 60) // 1 minute
}

const mock = vi.fn(() => console.log('executed'))

describe('delayed execution', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })
  afterEach(() => {
    vi.restoreAllMocks()
  })
  it('should execute the function', () => {
    executeAfterTwoHours(mock)
    vi.runAllTimers()
    expect(mock).toHaveBeenCalledTimes(1)
  })
  it('should not execute the function', () => {
    executeAfterTwoHours(mock)
    // advancing by 2ms won't trigger the func
    vi.advanceTimersByTime(2)
    expect(mock).not.toHaveBeenCalled()
  })
  it('should execute every minute', () => {
    executeEveryMinute(mock)
    vi.advanceTimersToNextTimer()
    expect(mock).toHaveBeenCalledTimes(1)
    vi.advanceTimersToNextTimer()
    expect(mock).toHaveBeenCalledTimes(2)
  })
})
```

--------------------------------

### Istanbul Coverage Instrumentation Example

Source: https://main.vitest.dev/guide/coverage

This JavaScript code snippet illustrates how Istanbul instruments source files to track code coverage. It shows simplified examples of counters for branches and functions, and how global variables are used to store coverage data.

```javascript
// Simplified example of branch and function coverage counters
const coverage = { // [!code ++]
  branches: { 1: [0, 0] }, // [!code ++]
  functions: { 1: 0 }, // [!code ++]
} // [!code ++]

export function getUsername(id) {
  // Function coverage increased when this is invoked  // [!code ++]
  coverage.functions['1']++ // [!code ++]

  if (id == null) {
    // Branch coverage increased when this is invoked  // [!code ++]
    coverage.branches['1'][0]++ // [!code ++]

    throw new Error('User ID is required')
  }
  // Implicit else coverage increased when if-statement condition not met  // [!code ++]
  coverage.branches['1'][1]++ // [!code ++]

  return database.getUser(id)
}

globalThis.__VITEST_COVERAGE__ ||= {} // [!code ++]
globalThis.__VITEST_COVERAGE__[filename] = coverage // [!code ++]
```

--------------------------------

### Create a Custom Vitest Environment

Source: https://main.vitest.dev/guide/environment

This example shows how to create a custom Vitest environment. It defines an exported object conforming to the 'Environment' interface, specifying a name, a Vite environment type, and optional setup and teardown functions for the Node.js VM context.

```typescript
import type { Environment } from 'vitest/runtime'

export default <Environment>{
  name: 'custom',
  viteEnvironment: 'ssr',
  // optional - only if you support "vmForks" or "vmThreads" pools
  async setupVM() {
    const vm = await import('node:vm')
    const context = vm.createContext()
    return {
      getVmContext() {
        return context
      },
      teardown() {
        // called after all tests with this env have been run
      }
    }
  },
  setup() {
    // custom setup
    return {
      teardown() {
        // called after all tests with this env have been run
      }
    }
  }
}
```

--------------------------------

### Vitest Global Setup: Named Exports

Source: https://main.vitest.dev/config/globalsetup

Demonstrates how to export named `setup` and `teardown` functions in a Vitest global setup file. The `setup` function runs before tests, and `teardown` runs after. Both receive the test project as an argument.

```js
export function setup(project) {
  console.log('setup')
}

export function teardown() {
  console.log('teardown')
}
```

--------------------------------

### CLI Example for Sequence Options

Source: https://main.vitest.dev/config/sequence

Demonstrates how to provide sequence options directly through the Vitest CLI using dot notation for configuration.

```sh
npx vitest --sequence.shuffle --sequence.seed=1000
```

--------------------------------

### Vitest Global Setup: Providing Data to Tests

Source: https://main.vitest.dev/config/globalsetup

Illustrates how to pass serializable data from a global setup file to tests using `project.provide`. Tests can then access this data using `inject` from Vitest. This requires defining the provided types in the Vitest module declaration.

```ts
import { inject } from 'vitest'

inject('wsPort') === 3000
```

```ts
import type { TestProject } from 'vitest/node'

export default function setup(project: TestProject) {
  project.provide('wsPort', 3000)
}

declare module 'vitest' {
  export interface ProvidedContext {
    wsPort: number
  }
}
```

--------------------------------

### startVitest API

Source: https://main.vitest.dev/guide/advanced

Starts Vitest tests programmatically. It accepts a run mode, optional CLI filters, CLI options, Vite configuration overrides, and Vitest specific options. It returns a Vitest instance.

```APIDOC
## POST /vitest/node/start

### Description
Starts Vitest tests programmatically. It accepts a run mode, optional CLI filters, CLI options, Vite configuration overrides, and Vitest specific options. It returns a Vitest instance.

### Method
POST

### Endpoint
/vitest/node/start

### Parameters
#### Query Parameters
- **mode** (VitestRunMode) - Required - The mode in which to run Vitest tests (e.g., 'test', 'benchmark').
- **cliFilters** (string[]) - Optional - An array of strings to filter test files by path.
- **options** (CliOptions) - Optional - An object containing CLI options to override test configuration.
- **viteOverrides** (ViteUserConfig) - Optional - An object containing Vite configuration to override.
- **vitestOptions** (VitestOptions) - Optional - An object containing Vitest specific options to override.

### Request Body
```json
{
  "mode": "test",
  "cliFilters": ["./src/components"]
}
```

### Response
#### Success Response (200)
- **vitestInstance** (Vitest) - The Vitest instance, providing access to test results and methods.

#### Response Example
```json
{
  "vitestInstance": { /* Vitest instance object */ }
}
```
```

--------------------------------

### Write a Simple JavaScript Function and its Test

Source: https://main.vitest.dev/guide

Demonstrates writing a basic JavaScript function `sum` and a corresponding Vitest test file `sum.test.js` to verify its functionality. The test uses `expect` and `test` from Vitest to assert that `sum(1, 2)` returns `3`.

```javascript
export function sum(a, b) {
  return a + b
}
```

```javascript
import { expect, test } from 'vitest'
import { sum } from './sum.js'

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3)
})
```

--------------------------------

### Parallel Execution and Randomization

Source: https://main.vitest.dev/guide/cli

Options related to parallel execution of tests and setup files, and setting a seed for randomization.

```APIDOC
## sequence.concurrent

### Description
Makes tests run in parallel.

### Method
CLI Flag / Config Option

### Endpoint
N/A

### Parameters
#### CLI Parameters
- `--sequence.concurrent` (boolean) - Enable this flag to run tests in parallel.

#### Config Parameters
- `sequence.concurrent` (boolean) - Set to `true` to run tests in parallel. Defaults to `false`.

### Request Example
```bash
vite test --sequence.concurrent
```

### Response
#### Success Response (0)
Tests are executed in parallel.

#### Response Example
N/A
```

```APIDOC
## sequence.seed

### Description
Sets the randomization seed. This option has no effect if `--sequence.shuffle` is falsy. Refer to the [Random Seed](https://en.wikipedia.org/wiki/Random_seed) page for more information.

### Method
CLI Flag / Config Option

### Endpoint
N/A

### Parameters
#### CLI Parameters
- `--sequence.seed <seed>` (string) - The seed value for randomization.

#### Config Parameters
- `sequence.seed` (string) - The seed value for randomization.

### Request Example
```bash
vite test --sequence.seed 12345
```

### Response
#### Success Response (0)
Randomization is seeded with the provided value.

#### Response Example
N/A
```

```APIDOC
## sequence.setupFiles

### Description
Changes the order in which setup files are executed. Accepted values are: "list" and "parallel". If set to "list", setup files run in the order they are defined. If set to "parallel", setup files run in parallel.

### Method
CLI Flag / Config Option

### Endpoint
N/A

### Parameters
#### CLI Parameters
- `--sequence.setupFiles <order>` (string) - The order for executing setup files ('list' or 'parallel').

#### Config Parameters
- `sequence.setupFiles` (string) - The order for executing setup files ('list' or 'parallel'). Defaults to `'parallel'`.

### Request Example
```bash
vite test --sequence.setupFiles list
```

### Response
#### Success Response (0)
Setup files are executed in the specified order.

#### Response Example
N/A
```

--------------------------------

### Vitest Object Syntax Fixture Setup (TypeScript)

Source: https://main.vitest.dev/guide/test-context

Demonstrates setting up a Playwright-compatible object syntax fixture in Vitest. This fixture, named 'page', sets up a new browser page before each test and closes it afterward. It also defines a 'baseUrl' fixture.

```typescript
import { test as baseTest } from 'vitest'

export const test = baseTest.extend({
  page: async ({}, use) => {
    // setup the fixture before each test function
    const page = await browser.newPage()

    // use the fixture value
    await use(page)

    // cleanup the fixture after each test function
    await page.close()
  },
  baseUrl: 'http://localhost:3000'
})
```

--------------------------------

### Implement Reporter with onInit and onTestRunStart in TypeScript

Source: https://main.vitest.dev/api/advanced/reporters

Provides an example of implementing the Reporter interface in TypeScript. It shows how to use the onInit method to store a reference to the Vitest instance and the onTestRunStart method to log the number of test files and the root directory. This example requires types from 'vitest/node'.

```typescript
import type { Reporter, TestSpecification, Vitest } from 'vitest/node'

class MyReporter implements Reporter {
  private vitest!: Vitest

  onInit(vitest: Vitest) {
    this.vitest = vitest
  }

  onTestRunStart(specifications: TestSpecification[]) {
    console.log(
      specifications.length,
      'test files will run in',
      this.vitest.config.root,
    )
  }
}

export default new MyReporter()
```

--------------------------------

### Customize Reporter Options

Source: https://main.vitest.dev/guide/reporters

Shows how to pass specific options to a reporter, using the 'junit' reporter as an example to set a suite name. This allows for more detailed and tailored test reporting.

```typescript
export default defineConfig({
  test: {
    reporters: [
      'default',
      ['junit', { suiteName: 'UI tests' }]
    ],
  },
})
```

--------------------------------

### Configure Node CLI Options per Project in Vitest

Source: https://main.vitest.dev/guide/migration

This example demonstrates how to specify Node.js CLI arguments on a per-project basis in Vitest. It uses the `execArgv` option to pass different environment file flags for production and staging environments.

```typescript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    projects: [
      {
        name: 'Production env',
        execArgv: ['--env-file=.env.prod']
      },
      {
        name: 'Staging env',
        execArgv: ['--env-file=.env.staging']
      },
    ],
  },
})
```

--------------------------------

### Initializing Vitest for Browser Testing (Bash)

Source: https://main.vitest.dev/guide/cli

Command to initialize Vitest project configuration specifically for browser testing.

```bash
vitest init browser
```

--------------------------------

### Render and Interact with Qwik Component in Vitest Browser

Source: https://main.vitest.dev/guide/browser

Shows how to test a Qwik component using `vitest-browser-qwik`. The example renders the component, simulates a click, and asserts the presence of a greeting message.

```tsx
import { render } from 'vitest-browser-qwik'
import Greeting from './greeting'

test('greeting appears on click', async () => {
  // renderSSR and renderHook are also available
  const screen = render(<Greeting />)

  const button = screen.getByRole('button')
  await button.click()
  const greeting = screen.getByText(/hello world/iu)

  await expect.element(greeting).toBeInTheDocument()
})
```

--------------------------------

### Vitest: Fixture Setup and Cleanup with `onCleanup` (TypeScript)

Source: https://main.vitest.dev/guide/test-context

Demonstrates how to use the `onCleanup` callback within a Vitest fixture to register teardown logic. This ensures resources like temporary files are cleaned up after a test completes. It requires the 'vitest' package and 'fs' module for file operations.

```typescript
import { test as baseTest } from 'vitest'
import fs from 'fs/promises'

export const test = baseTest
  .extend('tempFile', async ({}, { onCleanup }) => {
    const filePath = `/tmp/test-${Date.now()}.txt`
    await fs.writeFile(filePath, 'test data')

    // Register cleanup - runs after test completes
    onCleanup(async () => {
      await fs.unlink(filePath)
    })

    return filePath
  })
```

--------------------------------

### Vitest Global Setup: Handling Test Reruns

Source: https://main.vitest.dev/config/globalsetup

Demonstrates how to define a callback function for test reruns using `project.onTestsRerun`. This function will be executed and awaited before tests are rerun, allowing for setup tasks like restarting a database.

```ts
import type { TestProject } from 'vitest/node'

export default function setup(project: TestProject) {
  project.onTestsRerun(async () => {
    await restartDb()
  })
}
```

--------------------------------

### Configure Custom Pool for Projects - Vitest Config

Source: https://main.vitest.dev/guide/advanced/pool

This example shows how to configure different pools for different test projects within a single Vitest setup. It utilizes the `projects` feature to specify a default 'threads' pool for one project and a custom pool for another, allowing for granular control over test execution environments.

```typescript
import customPool from './my-custom-pool.ts'

export default defineConfig({
  test: {
    projects: [
      {
        extends: true,
        test: {
          pool: 'threads',
        },
      },
      {
        extends: true,
        test: {
          pool: customPool({
            customProperty: true,
          })
        }
      }
    ],
  },
})
```

--------------------------------

### Vitest Global Setup: Default Export

Source: https://main.vitest.dev/config/globalsetup

Shows how to use a default export for the setup function in Vitest. The default function receives the test project and should return a teardown function. This setup runs before tests, and the returned teardown runs after.

```js
export default function setup(project) {
  console.log('setup')

  return function teardown() {
    console.log('teardown')
  }
}
```

--------------------------------

### Vitest Nested Suite Execution Flow Example

Source: https://main.vitest.dev/guide/lifecycle

Illustrates the hierarchical execution of hooks in Vitest when using nested describe blocks. Shows how parent hooks wrap around child hooks and tests.

```typescript
describe('outer', () => {
  aroundAll(async (runSuite) => {
    console.log('outer aroundAll before')
    await runSuite()
    console.log('outer aroundAll after')
  })

  beforeAll(() => console.log('outer beforeAll'))

  aroundEach(async (runTest) => {
    console.log('outer aroundEach before')
    await runTest()
    console.log('outer aroundEach after')
  })

  beforeEach(() => console.log('outer beforeEach'))

  test('outer test', () => console.log('outer test'))

  describe('inner', () => {
    aroundAll(async (runSuite) => {
      console.log('inner aroundAll before')
      await runSuite()
      console.log('inner aroundAll after')
    })

    beforeAll(() => console.log('inner beforeAll'))

    aroundEach(async (runTest) => {
      console.log('inner aroundEach before')
      await runTest()
      console.log('inner aroundEach after')
    })

    beforeEach(() => console.log('inner beforeEach'))

    test('inner test', () => console.log('inner test'))

    afterEach(() => console.log('inner afterEach'))
    afterAll(() => console.log('inner afterAll'))
  })

  afterEach(() => console.log('outer afterEach'))
  afterAll(() => console.log('outer afterAll'))
})

```

--------------------------------

### Global Setup Configuration

Source: https://main.vitest.dev/config/globalsetup

Configure global setup files for Vitest. These files run before test workers are created and can export `setup` and `teardown` functions or a default function returning a teardown function. Data can be passed to tests using `project.provide()`.

```APIDOC
## Global Setup Configuration

### Description
Configure global setup and teardown logic for Vitest. These files execute before test workers are initialized and after all tests have finished, respectively. They can be used to set up the testing environment and clean it up afterwards. Data can be passed from the global scope to individual tests using the `project.provide()` method.

### Method
N/A (Configuration Option)

### Endpoint
N/A (Configuration Option)

### Parameters
#### Path Parameters
N/A

#### Query Parameters
N/A

#### Request Body
N/A

### Request Example
N/A

### Response
#### Success Response (N/A)
N/A

#### Response Example
N/A

## Global Setup File Structure

### Description
Defines the structure for global setup files in Vitest, supporting named `setup` and `teardown` exports or a default function that returns a teardown function.

### Method
N/A (File Structure)

### Endpoint
N/A (File Structure)

### Parameters
N/A

### Request Example
```js [exports]
export function setup(project) {
  console.log('setup')
}

export function teardown() {
  console.log('teardown')
}
```

```js [default]
export default function setup(project) {
  console.log('setup')

  return function teardown() {
    console.log('teardown')
  }
}
```

### Response
N/A

## Providing Data to Tests

### Description
Demonstrates how to pass serializable data from a global setup file to Vitest tests using the `project.provide()` method and how to access it in tests via `inject`.

### Method
N/A (API Usage)

### Endpoint
N/A (API Usage)

### Parameters
N/A

### Request Example
```ts [globalSetup.ts]
import type { TestProject } from 'vitest/node'

export default function setup(project: TestProject) {
  project.provide('wsPort', 3000)
}

declare module 'vitest' {
  export interface ProvidedContext {
    wsPort: number
  }
}
```

```ts [example.test.ts]
import { inject } from 'vitest'

inject('wsPort') === 3000
```

### Response
N/A

## Handling Test Reruns

### Description
Allows defining a custom callback function using `project.onTestsRerun()` that executes before Vitest reruns tests. This is useful for tasks like restarting a database.

### Method
N/A (API Usage)

### Endpoint
N/A (API Usage)

### Parameters
N/A

### Request Example
```ts [globalSetup.ts]
import type { TestProject } from 'vitest/node'

export default function setup(project: TestProject) {
  project.onTestsRerun(async () => {
    await restartDb()
  })
}
```

### Response
N/A
```

--------------------------------

### Vitest Test Execution Flow Example

Source: https://main.vitest.dev/guide/lifecycle

Demonstrates the execution order of Vitest hooks and tests within a single describe block. Includes file-level code, aroundAll, beforeAll, aroundEach, beforeEach, test, afterEach, and afterAll hooks.

```typescript
// This runs immediately (collection phase)
console.log('File loaded')

describe('User API', () => {
  // This runs immediately (collection phase)
  console.log('Suite defined')

  aroundAll(async (runSuite) => {
    // Wraps around all tests in this suite
    console.log('aroundAll before')
    await runSuite()
    console.log('aroundAll after')
  })

  beforeAll(() => {
    // Runs once before all tests in this suite
    console.log('beforeAll')
  })

  aroundEach(async (runTest) => {
    // Wraps around each test
    console.log('aroundEach before')
    await runTest()
    console.log('aroundEach after')
  })

  beforeEach(() => {
    // Runs before each test
    console.log('beforeEach')
  })

  test('creates user', () => {
    // Test executes
    console.log('test 1')
  })

  test('updates user', () => {
    // Test executes
    console.log('test 2')
  })

  afterEach(() => {
    // Runs after each test
    console.log('afterEach')
  })

  afterAll(() => {
    // Runs once after all tests in this suite
    console.log('afterAll')
  })
})

```

--------------------------------

### Start Test Run

Source: https://main.vitest.dev/api/advanced/vitest

Initializes reporters, the coverage provider, and runs tests. Accepts string filters to match test files, similar to the CLI.

```APIDOC
## start

### Description
Initialize reporters, the coverage provider, and run tests. This method accepts string filters to match the test files - these are the same filters that [CLI supports](/guide/filtering#cli).

::: warning
This method should not be called if [`vitest.init()`](#init) is also invoked. Use [`runTestSpecifications`](#runtestspecifications) or [`rerunTestSpecifications`](#reruntestspecifications) instead if you need to run tests after Vitest was initialised.
:::

This method is called automatically by [`startVitest`](/guide/advanced/tests) if `config.mergeReports` and `config.standalone` are not set.

### Method
POST

### Endpoint
/websites/main_vitest_dev/start

### Parameters
#### Query Parameters
- **filters** (string[]) - Optional - Filters to match test files.

### Response
#### Success Response (200)
- **TestRunResult** (object) - Result of the test run.

#### Response Example
```json
{
  "errors": [],
  "files": [
    {
      "name": "path/to/test.spec.ts",
      "result": {
        "state": "passed"
      }
    }
  ]
}
```
```

--------------------------------

### Inspect Rendered Output with Vitest Element Queries

Source: https://main.vitest.dev/guide/browser/component-testing

Provides examples of using Vitest's element query methods (`getByRole`, `getByTestId`) and `console.log` to inspect and debug why elements might not be found during component testing.

```tsx
// Debug why elements can't be found
const button = page.getByRole('button', { name: /submit/i })
console.log('Button count:', button.length) // Should be 1

// Try alternative queries if the first one fails
if (button.length === 0) {
  console.log('All buttons:', page.getByRole('button').length)
  console.log('By test ID:', page.getByTestId('submit-btn').length)
}
```

--------------------------------

### Browser Execution

Source: https://main.vitest.dev/guide/cli

Configure Vitest to run tests directly in a browser environment, providing a more realistic testing setup for web applications.

```APIDOC
## Browser Execution

### Description
Run your Vitest tests directly in a browser environment. This provides a more accurate representation of how your application behaves in a real browser.

### Method
CLI Flag / Config Option

### Parameters
#### CLI Parameters
- **--browser.enabled** (boolean) - Enable browser execution. Defaults to `false`.

#### Config Parameters
- **browser.enabled** (boolean) - Enables or disables browser execution. Defaults to `false`.

### Request Example
```bash
vitest --browser.enabled
```

### Response
#### Success Response
Tests are executed within a browser environment.

#### Response Example
(No specific response body, test execution context changes)
```

--------------------------------

### Configure Coverage Provider in Vitest

Source: https://main.vitest.dev/guide/coverage

This snippet shows how to configure the code coverage provider in Vitest's configuration file. You can choose between 'v8' (default) or 'istanbul'. Vitest will prompt to install the necessary support package automatically or you can install them manually.

```typescript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      provider: 'v8' // or 'istanbul'
    },
  },
})
```

--------------------------------

### Render Marko Component and Assert Text with @marko/testing-library

Source: https://main.vitest.dev/guide/browser

This example demonstrates testing a Marko component using `@marko/testing-library`. It renders the `Greeting` component with a name prop and asserts that the rendered output contains the expected text.

```ts
// based on @testing-library/marko API
// https://testing-library.com/docs/marko-testing-library/api

import { render, screen } from '@marko/testing-library'
import Greeting from './greeting.marko'

test('renders a message', async () => {
  const { baseElement } = await render(Greeting, { name: 'Marko' })
  const screen = page.elementLocator(baseElement)
  await expect.element(screen.getByText(/Marko/)).toBeInTheDocument()
  expect(container.firstChild).toMatchInlineSnapshot(`
    <h1>Hello, Marko!</h1>
  `)
})
```

--------------------------------

### Comprehensive Test Tag Configuration Example

Source: https://main.vitest.dev/config/tags

This comprehensive example demonstrates defining multiple test tags with various properties including name, description, timeout, retry logic, and skip conditions. It showcases how tags can be configured for different testing scenarios.

```typescript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    tags: [
      {
        name: 'unit',
        description: 'Unit tests.',
      },
      {
        name: 'e2e',
        description: 'End-to-end tests.',
        timeout: 60_000,
      },
      {
        name: 'flaky',
        description: 'Flaky tests that need retries.',
        retry: process.env.CI ? 3 : 0,
        priority: 1,
      },
      {
        name: 'slow',
        description: 'Slow tests.',
        timeout: 120_000,
      },
      {
        name: 'skip-ci',
        description: 'Tests to skip in CI.',
        skip: !!process.env.CI,
      },
    ],
  },
})
```

--------------------------------

### Start Vitest Programmatically (JavaScript)

Source: https://main.vitest.dev/guide/advanced

Starts Vitest tests programmatically using the `startVitest` function. It accepts run mode, optional CLI filters, options, Vite overrides, and Vitest options. It returns a Vitest instance. If watch mode is disabled, `close` is called automatically. Watch mode enables console shortcuts if the terminal supports TTY.

```javascript
import { startVitest } from 'vitest/node'

const vitest = await startVitest('test')

await vitest.close()
```

--------------------------------

### Start Vitest Programmatically (TypeScript)

Source: https://main.vitest.dev/guide/advanced

Starts Vitest tests programmatically using the `startVitest` function. It accepts run mode, optional CLI filters, options, Vite overrides, and Vitest options. It returns a Vitest instance. If watch mode is disabled, `close` is called automatically. Watch mode enables console shortcuts if the terminal supports TTY.

```typescript
import type { TestModule } from 'vitest/node'

const vitest = await startVitest('test')

console.log(vitest.state.getTestModules()) // [TestModule]
```

--------------------------------

### Custom Reporter Configuration

Source: https://main.vitest.dev/guide/reporters

Uses third-party or local custom reporters. Install from NPM and specify the package name via CLI or config. Local reporters can be specified using their file path.

```bash
npx vitest --reporter=some-published-vitest-reporter
```

```typescript
export default defineConfig({
  test: {
    reporters: ['some-published-vitest-reporter']
  },
})
```

```bash
npx vitest --reporter=./path/to/reporter.ts
```

--------------------------------

### Open Vitest UI Automatically

Source: https://main.vitest.dev/guide/cli

Automatically opens the Vitest UI in the browser after tests start. Defaults to not opening in CI environments. Use '--open' on the CLI.

```bash
vitest --open
```

--------------------------------

### Testing Product List Filtering and Display with Vitest (React)

Source: https://main.vitest.dev/guide/browser/component-testing

Illustrates an integration testing strategy for a ProductList component. This example shows how to test the component's ability to filter products based on category and display the results accurately, simulating user interactions like selecting from a dropdown.

```tsx
test('ProductList filters and displays products correctly', async () => {
  const mockProducts = [
    { id: 1, name: 'Laptop', category: 'Electronics', price: 999 },
    { id: 2, name: 'Book', category: 'Education', price: 29 }
  ]

  const { getByLabelText, getByText } = render(
    <ProductList products={mockProducts} />
  )

  // Initially shows all products
  await expect.element(getByText('Laptop')).toBeInTheDocument()
  await expect.element(getByText('Book')).toBeInTheDocument()

  // Filter by category
  await userEvent.selectOptions(
    getByLabelText(/category/i),
    'Electronics'
  )

  // Only electronics should remain
  await expect.element(getByText('Laptop')).toBeInTheDocument()
  await expect.element(queryByText('Book')).not.toBeInTheDocument()
})
```

--------------------------------

### Implement a Custom Coverage Reporter (JavaScript)

Source: https://main.vitest.dev/guide/coverage

Example of a custom coverage reporter written in JavaScript (CommonJS). This reporter extends `istanbul-lib-report`'s `ReportBase` and implements `onStart` and `onEnd` methods to write custom content to a file.

```javascript
const { ReportBase } = require('istanbul-lib-report')

module.exports = class CustomReporter extends ReportBase {
  constructor(opts) {
    super()

    // Options passed from configuration are available here
    this.file = opts.file
  }

  onStart(root, context) {
    this.contentWriter = context.writer.writeFile(this.file)
    this.contentWriter.println('Start of custom coverage report')
  }

  onEnd() {
    this.contentWriter.println('End of custom coverage report')
    this.contentWriter.close()
  }
}
```

--------------------------------

### Project and Test Execution Options

Source: https://main.vitest.dev/guide/cli

Options for managing projects in a workspace and controlling test execution behavior.

```APIDOC
## Project and Test Execution Options

### project

* **CLI:** `--project <name>`

The name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: `--project=1 --project=2`. You can also filter projects using wildcards like `--project=packages*`, and exclude projects with `--project=!pattern`.

### slowTestThreshold

* **CLI:** `--slowTestThreshold <threshold>`
* **Config:** [slowTestThreshold](/config/slowtestthreshold)

Threshold in milliseconds for a test or suite to be considered slow (default: `300`)

### teardownTimeout

* **CLI:** `--teardownTimeout <timeout>`
* **Config:** [teardownTimeout](/config/teardowntimeout)

Default timeout of a teardown function in milliseconds (default: `10000`)

### maxConcurrency

* **CLI:** `--maxConcurrency <number>`
* **Config:** [maxConcurrency](/config/maxconcurrency)

Maximum number of concurrent tests in a suite (default: `5`)

### expect.requireAssertions

* **CLI:** `--expect.requireAssertions`
* **Config:** [expect.requireAssertions](/config/expect#expect-requireassertions)

Require that all tests have at least one assertion
```

--------------------------------

### Configure Vue Snapshot Serializer in Vitest

Source: https://main.vitest.dev/guide/migration

To handle Vue snapshots correctly in Vitest, similar to Jest with the vue-cli preset, you need to install `jest-serializer-vue` and configure it in `snapshotSerializers`. This snippet shows the `vitest.config.js` setup.

```javascript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    snapshotSerializers: ['jest-serializer-vue']
  }
})
```

--------------------------------

### createVitest API

Source: https://main.vitest.dev/guide/advanced

Creates a Vitest instance without starting the tests. This is useful for scenarios where you need a Vitest instance but want to control the test execution flow manually. It returns the same Vitest instance as `startVitest`.

```APIDOC
## POST /vitest/node/create

### Description
Creates a Vitest instance without starting the tests. This is useful for scenarios where you need a Vitest instance but want to control the test execution flow manually. It returns the same Vitest instance as `startVitest`.

### Method
POST

### Endpoint
/vitest/node/create

### Parameters
#### Query Parameters
- **mode** (VitestRunMode) - Required - The mode in which to create the Vitest instance (e.g., 'test', 'benchmark').
- **options** (CliOptions) - Required - An object containing CLI options to configure the Vitest instance.
- **viteOverrides** (ViteUserConfig) - Optional - An object containing Vite configuration to override.
- **vitestOptions** (VitestOptions) - Optional - An object containing Vitest specific options to override.

### Request Body
```json
{
  "mode": "test",
  "options": {
    "watch": false
  }
}
```

### Response
#### Success Response (200)
- **vitestInstance** (Vitest) - The created Vitest instance.

#### Response Example
```json
{
  "vitestInstance": { /* Vitest instance object */ }
}
```
```

--------------------------------

### Browser Headless Mode

Source: https://main.vitest.dev/guide/cli

Configure the browser to run in headless mode, which is useful for CI environments.

```APIDOC
## Browser Headless Mode

### Description
Run the browser in headless mode, meaning without a graphical user interface. This is automatically enabled by default when Vitest detects it's running in a CI environment.

### Method
CLI Flag / Config Option

### Parameters
#### CLI Parameters
- **--browser.headless** (boolean) - Enable headless mode for the browser.

#### Config Parameters
- **browser.headless** (boolean) - Controls headless mode. Defaults to `process.env.CI`.

### Request Example
```bash
vitest --browser.headless
```

### Response
#### Success Response
Browser tests will run without displaying a GUI.

#### Response Example
(No specific response body, affects browser execution)
```

--------------------------------

### Setup User Event Instance in Vitest

Source: https://main.vitest.dev/api/browser/interactivity

Illustrates the creation of a new user event instance using `userEvent.setup()` in Vitest. This is particularly useful for maintaining keyboard state across multiple interactions, unlike the default global instance.

```typescript
function setup(): UserEvent

// Example usage:
// const customUserEvent = userEvent.setup()
// await customUserEvent.keyboard('{Shift}')
```

--------------------------------

### Configure Multiple Browser Instances (TypeScript)

Source: https://main.vitest.dev/config/browser/instances

Demonstrates how to configure multiple browser instances for testing. Each instance can have its own setup files and inherits options like `testerHtmlPath` from the root configuration. This setup enables running tests across different browser environments.

```typescript
export default defineConfig({
  test: {
    setupFile: ['./root-setup-file.js'],
    browser: {
      enabled: true,
      testerHtmlPath: './custom-path.html',
      instances: [
        {
          // will have both setup files: "root" and "browser"
          setupFile: ['./browser-setup-file.js'],
          // implicitly has "testerHtmlPath" from the root config // [!code warning]
          // testerHtmlPath: './custom-path.html', // [!code warning]
        },
      ],
    },
  },
})
```

--------------------------------

### Configuring Vitest for Lint Staging (JavaScript)

Source: https://main.vitest.dev/guide/cli

An example configuration for `.lintstagedrc.js` to run `vitest related --run` on staged JavaScript and TypeScript files. The `--run` option ensures the command exits normally.

```javascript
export default {
  '*.{js,ts}': 'vitest related --run',
}
```

--------------------------------

### Mock External Dependencies with Vitest

Source: https://main.vitest.dev/guide/browser/component-testing

This example demonstrates how to mock external dependencies in Vitest to isolate component logic and improve test reliability and speed. It suggests using Mock Service Worker (MSW) for API request mocking and Vitest's `vi.mock()` for module mocking, showing how to replace components with mock implementations.

```javascript
// For API requests, we recommend using MSW (Mock Service Worker)
// See: https://vitest.dev/guide/mocking/requests
// This provides more realistic request/response mocking

// For module mocking, use the import() syntax
vi.mock(import('../components/UserCard'), () => ({
  default: vi.fn(() => <div>Mocked UserCard</div>)
}))
```

--------------------------------

### Setting up Zsh Autocompletions for Vitest (Shell)

Source: https://main.vitest.dev/guide/cli

Instructions to add Vitest shell autocompletions to the Zsh configuration file for permanent use.

```shell
# Add to ~/.zshrc for permanent autocompletions (same can be done for other shells)
source <(vitest complete zsh)
```

--------------------------------

### Create Vitest Instance (JavaScript)

Source: https://main.vitest.dev/guide/advanced

Creates a Vitest instance without starting tests or validating packages using the `createVitest` function. It requires a run mode and options, and optionally accepts Vite overrides and Vitest options. It returns the same Vitest instance as `startVitest`.

```javascript
import { createVitest } from 'vitest/node'

const vitest = await createVitest('test', {
  watch: false,
})
```

--------------------------------

### Configure Vitest Standalone Mode in package.json

Source: https://main.vitest.dev/guide/migration

Shows how to configure Vitest to run in standalone mode using a `package.json` script. This setup allows for easy execution of Vitest in standalone mode and the ability to specify files to run directly from the command line.

```json
{
  "scripts": {
    "test:dev": "vitest --standalone"
  }
}
```

--------------------------------

### Install OpenTelemetry Browser Packages

Source: https://main.vitest.dev/guide/open-telemetry

Installs the necessary OpenTelemetry packages for browser instrumentation, including the web tracer provider and an OTLP trace exporter. These are required for capturing traces from tests running in the browser.

```shell
npm i @opentelemetry/sdk-trace-web @opentelemetry/exporter-trace-otlp-proto
```