# Bun

Bun is an all-in-one toolkit for JavaScript and TypeScript applications, shipping as a single executable. At its core is the Bun runtime, a fast JavaScript runtime designed as a drop-in replacement for Node.js. Written in Zig and powered by JavaScriptCore, Bun dramatically reduces startup times and memory usage compared to Node.js. It natively supports TypeScript and JSX out of the box without any configuration.

Beyond the runtime, Bun includes a Node.js-compatible package manager (up to 25x faster than npm), a native bundler, and a Jest-compatible test runner. The toolkit provides built-in APIs for HTTP servers, WebSockets, SQLite, file I/O, shell scripting, and more. Bun aims to be a cohesive infrastructure for building modern JavaScript/TypeScript applications with zero configuration required for common use cases.

## HTTP Server with Bun.serve()

The `Bun.serve()` API creates high-performance HTTP servers with built-in routing support. It handles roughly 2.5x more requests per second than Node.js and supports WebSocket upgrades, TLS, and hot route reloading without server restarts.

```typescript
const server = Bun.serve({
  port: 3000,
  routes: {
    // Static response
    "/api/health": new Response("OK"),

    // Dynamic route with params
    "/users/:id": (req) => {
      return Response.json({ userId: req.params.id });
    },

    // Per-method handlers
    "/api/posts": {
      GET: () => Response.json({ posts: [] }),
      POST: async (req) => {
        const body = await req.json();
        return Response.json({ created: true, ...body }, { status: 201 });
      },
    },

    // Serve static files
    "/favicon.ico": Bun.file("./favicon.ico"),

    // Wildcard catch-all
    "/api/*": Response.json({ error: "Not found" }, { status: 404 }),
  },

  // Fallback for unmatched routes
  fetch(req) {
    return new Response("Not Found", { status: 404 });
  },

  // Error handler
  error(error) {
    console.error(error);
    return new Response("Internal Server Error", { status: 500 });
  },
});

console.log(`Server running at ${server.url}`);

// Hot reload routes without restart
server.reload({
  routes: {
    "/api/version": () => Response.json({ version: "2.0.0" }),
  },
});

// Graceful shutdown
await server.stop();
```

## WebSocket Server

Bun's WebSocket implementation delivers 7x more throughput than Node.js with ws, featuring native pub/sub, per-message compression, and automatic backpressure handling.

```typescript
type WebSocketData = {
  username: string;
  joinedAt: number;
};

const server = Bun.serve({
  fetch(req, server) {
    const url = new URL(req.url);

    if (url.pathname === "/chat") {
      const username = url.searchParams.get("username") || "anonymous";

      // Upgrade HTTP to WebSocket
      const success = server.upgrade(req, {
        data: { username, joinedAt: Date.now() },
        headers: { "Set-Cookie": "session=abc123" },
      });

      return success ? undefined : new Response("Upgrade failed", { status: 500 });
    }

    return new Response("Hello!");
  },

  websocket: {
    // Type ws.data
    data: {} as WebSocketData,

    open(ws) {
      ws.subscribe("general");
      server.publish("general", `${ws.data.username} joined the chat`);
    },

    message(ws, message) {
      // Broadcast to all subscribers except sender
      ws.publish("general", `${ws.data.username}: ${message}`);
    },

    close(ws) {
      ws.unsubscribe("general");
      server.publish("general", `${ws.data.username} left the chat`);
    },

    // Configuration
    maxPayloadLength: 1024 * 1024, // 1MB max message
    idleTimeout: 120, // seconds
    perMessageDeflate: true, // enable compression
  },
});

// Server can also publish to topics
server.publish("general", "Server announcement!");
console.log(`WebSocket server at ws://localhost:${server.port}/chat`);
```

## File I/O with Bun.file() and Bun.write()

Bun provides optimized file APIs using the fastest available system calls (copy_file_range, clonefile, sendfile). The `BunFile` class is a lazy-loaded file reference implementing the Blob interface.

```typescript
// Reading files
const file = Bun.file("data.json");

console.log(file.size);    // bytes
console.log(file.type);    // MIME type

const text = await file.text();           // as string
const json = await file.json();           // parsed JSON
const buffer = await file.arrayBuffer();  // as ArrayBuffer
const bytes = await file.bytes();         // as Uint8Array
const stream = file.stream();             // as ReadableStream

// Check existence
const exists = await file.exists();

// Writing files
await Bun.write("output.txt", "Hello, World!");
await Bun.write("data.json", JSON.stringify({ key: "value" }));

// Copy file
const input = Bun.file("source.txt");
await Bun.write("dest.txt", input);

// Write HTTP response body to file
const response = await fetch("https://example.com");
await Bun.write("page.html", response);

// Write to stdout
await Bun.write(Bun.stdout, "Hello stdout!\n");

// Incremental writing with FileSink
const writer = Bun.file("log.txt").writer({ highWaterMark: 1024 * 1024 });
writer.write("Line 1\n");
writer.write("Line 2\n");
writer.flush();  // flush buffer to disk
writer.end();    // flush and close

// Delete files
await Bun.file("temp.txt").delete();

// Read directories (using node:fs)
import { readdir, mkdir } from "node:fs/promises";

const files = await readdir("./src", { recursive: true });
await mkdir("path/to/dir", { recursive: true });
```

## SQLite Database (bun:sqlite)

Bun includes a high-performance SQLite3 driver that is 3-6x faster than better-sqlite3. The API is synchronous and supports transactions, prepared statements, and class mapping.

```typescript
import { Database } from "bun:sqlite";

// Open database (use ":memory:" for in-memory)
const db = new Database("app.db", { create: true, strict: true });

// Enable WAL mode for better performance
db.run("PRAGMA journal_mode = WAL;");

// Create table
db.run(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
  )
`);

// Prepared statements (cached)
const insertUser = db.query("INSERT INTO users (name, email) VALUES ($name, $email)");
const findUser = db.query("SELECT * FROM users WHERE id = $id");
const allUsers = db.query("SELECT * FROM users");

// Insert with named parameters
const result = insertUser.run({ name: "Alice", email: "alice@example.com" });
console.log(result.lastInsertRowid); // inserted ID
console.log(result.changes);          // rows affected

// Query methods
const user = findUser.get({ id: 1 });     // single row or null
const users = allUsers.all();              // array of rows
const values = allUsers.values();          // array of arrays

// Iterate large results
for (const row of allUsers.iterate()) {
  console.log(row.name);
}

// Map results to class instances
class User {
  id!: number;
  name!: string;
  email!: string;

  get displayName() {
    return `${this.name} <${this.email}>`;
  }
}

const typedUsers = db.query("SELECT * FROM users").as(User).all();
console.log(typedUsers[0].displayName);

// Transactions
const insertMany = db.transaction((users: { name: string; email: string }[]) => {
  for (const user of users) {
    insertUser.run(user);
  }
  return users.length;
});

const count = insertMany([
  { name: "Bob", email: "bob@example.com" },
  { name: "Carol", email: "carol@example.com" },
]);

// Using `using` for automatic cleanup
{
  using db = new Database("temp.db");
  using query = db.query("SELECT 1 as value");
  console.log(query.get());
}

// Serialize/deserialize database
const backup = db.serialize();  // Uint8Array
const restored = Database.deserialize(backup);

db.close();
```

## Shell Scripting ($)

Bun Shell provides cross-platform bash-like scripting with JavaScript interop. It's safe by default (escapes all interpolated values) and supports pipes, redirection, environment variables, and globs.

```typescript
import { $ } from "bun";

// Basic commands
await $`echo "Hello World!"`;

// Capture output
const result = await $`echo "Hello"`.text();
console.log(result);  // "Hello\n"

// Quiet mode (no stdout)
await $`npm install`.quiet();

// Read as JSON
const pkg = await $`cat package.json`.json();

// Read line by line
for await (const line of $`cat file.txt`.lines()) {
  console.log(line);
}

// Error handling
try {
  await $`exit 1`.text();
} catch (err) {
  console.log(`Failed: ${err.exitCode}`);
  console.log(err.stderr.toString());
}

// Disable throwing on error
const { exitCode, stdout, stderr } = await $`might-fail`.nothrow().quiet();
if (exitCode !== 0) {
  console.error("Command failed");
}

// Piping
const wordCount = await $`echo "one two three" | wc -w`.text();

// Redirection with JavaScript objects
const buffer = Buffer.alloc(100);
await $`echo "Hello" > ${buffer}`;

const response = new Response("request body");
const output = await $`cat < ${response}`.text();

// Environment variables
await $`FOO=bar bun -e 'console.log(process.env.FOO)'`;

// Change env for single command
await $`echo $MY_VAR`.env({ MY_VAR: "value" });

// Change working directory
await $`pwd`.cwd("/tmp");

// Command substitution
await $`echo "Commit: $(git rev-parse HEAD)"`;

// Brace expansion
const expanded = $.braces("file{1,2,3}.txt");
// => ["file1.txt", "file2.txt", "file3.txt"]

// Safe escaping (prevents injection)
const userInput = "; rm -rf /";
await $`echo ${userInput}`;  // prints "; rm -rf /"

// Raw (unescaped) values
await $`echo ${{ raw: "$(date)" }}`;
```

## JavaScript Bundler (Bun.build)

Bun's native bundler supports TypeScript, JSX, tree-shaking, code splitting, and multiple output formats. It's significantly faster than esbuild for bundling operations.

```typescript
// Basic bundling
const result = await Bun.build({
  entrypoints: ["./src/index.tsx"],
  outdir: "./dist",
});

if (!result.success) {
  console.error("Build failed:", result.logs);
}

// Full configuration
await Bun.build({
  entrypoints: ["./src/app.ts", "./src/worker.ts"],
  outdir: "./dist",

  // Target environment
  target: "browser",  // "browser" | "bun" | "node"
  format: "esm",      // "esm" | "cjs" | "iife"

  // Code splitting
  splitting: true,

  // Minification
  minify: true,
  // Or granular control:
  // minify: { whitespace: true, syntax: true, identifiers: true },

  // Sourcemaps
  sourcemap: "linked",  // "none" | "linked" | "inline" | "external"

  // External packages (not bundled)
  external: ["react", "react-dom"],

  // Mark all packages as external
  packages: "external",

  // Environment variables
  env: "inline",  // Inline process.env values
  // env: "PUBLIC_*",  // Only inline PUBLIC_ prefixed vars

  // Define compile-time constants
  define: {
    "process.env.NODE_ENV": JSON.stringify("production"),
    "API_URL": JSON.stringify("https://api.example.com"),
  },

  // Drop console/debugger
  drop: ["console", "debugger"],

  // Custom file naming
  naming: {
    entry: "[dir]/[name]-[hash].[ext]",
    chunk: "chunks/[name]-[hash].[ext]",
    asset: "assets/[name]-[hash].[ext]",
  },

  // Banner/footer
  banner: '"use client";',
  footer: "// Built with Bun",

  // Plugins
  plugins: [/* custom plugins */],

  // Generate metafile for analysis
  metafile: "./dist/meta.json",
});

// Process outputs
for (const output of result.outputs) {
  console.log(output.path);   // file path
  console.log(output.kind);   // "entry-point" | "chunk" | "asset"
  console.log(output.hash);   // content hash

  // BuildArtifact extends Blob
  const text = await output.text();

  // Serve directly
  new Response(output);  // Content-Type auto-set
}

// CLI equivalent
// bun build ./src/index.tsx --outdir ./dist --minify --splitting --sourcemap linked

// Compile to standalone executable
// bun build ./cli.ts --compile --outfile ./mycli

// In-memory bundling (virtual files)
await Bun.build({
  entrypoints: ["/app/index.ts"],
  files: {
    "/app/index.ts": `
      import { greet } from "./lib.ts";
      console.log(greet("World"));
    `,
    "/app/lib.ts": `
      export const greet = (name: string) => "Hello, " + name;
    `,
  },
});
```

## Test Runner (bun:test)

Bun includes a Jest-compatible test runner with built-in TypeScript support, snapshots, mocks, and code coverage. Tests run significantly faster than Jest.

```typescript
import { describe, test, expect, beforeEach, afterEach, mock, spyOn } from "bun:test";

// Basic test
test("addition works", () => {
  expect(2 + 2).toBe(4);
});

// Async test
test("async operation", async () => {
  const data = await Promise.resolve({ value: 42 });
  expect(data.value).toBe(42);
});

// Test with timeout
test("slow operation", async () => {
  await new Promise(resolve => setTimeout(resolve, 100));
}, 500); // must complete in 500ms

// Grouped tests
describe("Calculator", () => {
  let calc: Calculator;

  beforeEach(() => {
    calc = new Calculator();
  });

  afterEach(() => {
    calc.reset();
  });

  test("adds numbers", () => {
    expect(calc.add(2, 3)).toBe(5);
  });

  test("subtracts numbers", () => {
    expect(calc.subtract(5, 3)).toBe(2);
  });
});

// Parametrized tests
test.each([
  [1, 2, 3],
  [2, 3, 5],
  [10, 20, 30],
])("%d + %d = %d", (a, b, expected) => {
  expect(a + b).toBe(expected);
});

// Conditional tests
test.if(process.platform === "darwin")("macOS only", () => {
  // runs only on macOS
});

test.skipIf(process.env.CI)("skip in CI", () => {
  // skipped in CI environments
});

// Skip and todo
test.skip("not implemented yet", () => {});
test.todo("implement later");

// Retry flaky tests
test("flaky network", async () => {
  const res = await fetch("https://api.example.com");
  expect(res.ok).toBe(true);
}, { retry: 3 });

// Assertions
expect(value).toBe(expected);
expect(value).toEqual(expected);
expect(value).toBeNull();
expect(value).toBeDefined();
expect(value).toBeTruthy();
expect(array).toContain(item);
expect(array).toHaveLength(3);
expect(string).toMatch(/pattern/);
expect(obj).toHaveProperty("key", "value");
expect(number).toBeGreaterThan(5);
expect(number).toBeCloseTo(0.3, 5);
expect(fn).toThrow("error message");

// Promise assertions
await expect(promise).resolves.toBe(value);
await expect(promise).rejects.toThrow();

// Mocking
const mockFn = mock((x: number) => x * 2);
mockFn(5);
expect(mockFn).toHaveBeenCalledWith(5);
expect(mockFn).toHaveReturnedWith(10);

// Spy on methods
const obj = { method: () => "original" };
const spy = spyOn(obj, "method").mockReturnValue("mocked");
expect(obj.method()).toBe("mocked");
spy.mockRestore();

// Snapshots
expect(data).toMatchSnapshot();
expect(html).toMatchInlineSnapshot(`"<div>Hello</div>"`);

// Run tests
// bun test
// bun test --watch
// bun test --coverage
// bun test --timeout 10000
```

## Package Manager (bun install)

Bun's package manager is up to 25x faster than npm, featuring a global cache, hardlinks, and automatic pnpm migration. It's fully compatible with npm registries and package.json.

```bash
# Install all dependencies
bun install

# Add packages
bun add react react-dom
bun add typescript --dev
bun add lodash@4.17.21  # specific version

# Remove packages
bun remove lodash

# Update packages
bun update
bun update react

# Global install
bun add --global typescript

# Production install (no devDependencies)
bun install --production

# Frozen lockfile (CI/CD)
bun install --frozen-lockfile
bun ci  # alias for frozen-lockfile install

# Check outdated
bun outdated

# Execute packages (like npx)
bunx cowsay "Hello!"
bunx --bun vite  # run with Bun runtime

# Workspaces
bun install --filter 'pkg-*'

# Scripts
bun run build
bun run dev
bun run test
```

```json
// package.json
{
  "name": "my-app",
  "scripts": {
    "dev": "bun --hot src/index.ts",
    "build": "bun build src/index.ts --outdir dist",
    "test": "bun test"
  },
  "dependencies": {
    "react": "^18.2.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  },
  "trustedDependencies": ["esbuild"],
  "workspaces": ["packages/*"]
}
```

```toml
# bunfig.toml
[install]
optional = true
dev = true
peer = true
frozenLockfile = false

[install.scopes]
"@mycompany" = "https://npm.mycompany.com"

[test]
coverage = true
coverageThreshold = { line = 80, function = 80 }
```

## Summary

Bun serves as a complete JavaScript/TypeScript development toolkit, replacing Node.js, npm, webpack, and Jest with a single fast binary. Its primary use cases include building high-performance HTTP servers and APIs with `Bun.serve()`, creating real-time applications with WebSocket support, bundling frontend applications with tree-shaking and code splitting, and running Jest-compatible tests with native TypeScript support. The built-in SQLite driver and shell scripting APIs enable full-stack applications without external dependencies.

Integration with existing Node.js projects is seamless since Bun supports CommonJS, ES modules, and the npm registry. Teams can incrementally adopt Bun by first using `bun install` for faster dependency installation, then migrating scripts to `bun run`, and eventually replacing Node.js runtime for significant performance gains. The consistent API design across all tools (bundler, test runner, runtime) reduces context switching and configuration complexity, making Bun ideal for both new projects and gradual migration of existing codebases.
